/* Generated by DBCC, see <https://github.com/howerj/dbcc> */
#include "tesla_can.h"
#include <inttypes.h>

#define UNUSED(X) ((void)(X))

static inline uint64_t reverse_byte_order(uint64_t x)
{
	x = (x & 0x00000000FFFFFFFF) << 32 | (x & 0xFFFFFFFF00000000) >> 32;
	x = (x & 0x0000FFFF0000FFFF) << 16 | (x & 0xFFFF0000FFFF0000) >> 16;
	x = (x & 0x00FF00FF00FF00FF) << 8  | (x & 0xFF00FF00FF00FF00) >> 8;
	return x;
}

static inline int phelper(int r, int print_return_value)
{
	return ((r >= 0) && (print_return_value >= 0)) ? r + print_return_value : -1;
}

can_0x003_STW_ANGL_STAT_t can_0x003_STW_ANGL_STAT_data;
can_0x00e_STW_ANGLHP_STAT_t can_0x00e_STW_ANGLHP_STAT_data;
can_0x045_STW_ACTN_RQ_t can_0x045_STW_ACTN_RQ_data;
can_0x06d_SBW_RQ_SCCM_t can_0x06d_SBW_RQ_SCCM_data;
can_0x101_GTW_epasControl_t can_0x101_GTW_epasControl_data;
can_0x108_DI_torque1_t can_0x108_DI_torque1_data;
can_0x118_DI_torque2_t can_0x118_DI_torque2_data;
can_0x135_ESP_135h_t can_0x135_ESP_135h_data;
can_0x155_ESP_B_t can_0x155_ESP_B_data;
can_0x214_EPB_epasControl_t can_0x214_EPB_epasControl_data;
can_0x283_BODY_R1_t can_0x283_BODY_R1_data;
can_0x2f8_MCU_gpsVehicleSpeed_t can_0x2f8_MCU_gpsVehicleSpeed_data;
can_0x318_GTW_carState_t can_0x318_GTW_carState_data;
can_0x348_GTW_status_t can_0x348_GTW_status_data;
can_0x368_DI_state_t can_0x368_DI_state_data;
can_0x370_EPAS_sysStatus_t can_0x370_EPAS_sysStatus_data;
can_0x388_MCU_clusterBacklightRequest_t can_0x388_MCU_clusterBacklightRequest_data;
can_0x3d8_MCU_locationStatus_t can_0x3d8_MCU_locationStatus_data;
can_0x488_DAS_steeringControl_t can_0x488_DAS_steeringControl_data;

int unpack_message(unsigned id, uint64_t data, uint8_t dlc)
{
	switch(id) {
	case 0x003: return unpack_can_0x003_STW_ANGL_STAT(&can_0x003_STW_ANGL_STAT_data, data, dlc);
	case 0x00e: return unpack_can_0x00e_STW_ANGLHP_STAT(&can_0x00e_STW_ANGLHP_STAT_data, data, dlc);
	case 0x045: return unpack_can_0x045_STW_ACTN_RQ(&can_0x045_STW_ACTN_RQ_data, data, dlc);
	case 0x06d: return unpack_can_0x06d_SBW_RQ_SCCM(&can_0x06d_SBW_RQ_SCCM_data, data, dlc);
	case 0x101: return unpack_can_0x101_GTW_epasControl(&can_0x101_GTW_epasControl_data, data, dlc);
	case 0x108: return unpack_can_0x108_DI_torque1(&can_0x108_DI_torque1_data, data, dlc);
	case 0x118: return unpack_can_0x118_DI_torque2(&can_0x118_DI_torque2_data, data, dlc);
	case 0x135: return unpack_can_0x135_ESP_135h(&can_0x135_ESP_135h_data, data, dlc);
	case 0x155: return unpack_can_0x155_ESP_B(&can_0x155_ESP_B_data, data, dlc);
	case 0x214: return unpack_can_0x214_EPB_epasControl(&can_0x214_EPB_epasControl_data, data, dlc);
	case 0x283: return unpack_can_0x283_BODY_R1(&can_0x283_BODY_R1_data, data, dlc);
	case 0x2f8: return unpack_can_0x2f8_MCU_gpsVehicleSpeed(&can_0x2f8_MCU_gpsVehicleSpeed_data, data, dlc);
	case 0x318: return unpack_can_0x318_GTW_carState(&can_0x318_GTW_carState_data, data, dlc);
	case 0x348: return unpack_can_0x348_GTW_status(&can_0x348_GTW_status_data, data, dlc);
	case 0x368: return unpack_can_0x368_DI_state(&can_0x368_DI_state_data, data, dlc);
	case 0x370: return unpack_can_0x370_EPAS_sysStatus(&can_0x370_EPAS_sysStatus_data, data, dlc);
	case 0x388: return unpack_can_0x388_MCU_clusterBacklightRequest(&can_0x388_MCU_clusterBacklightRequest_data, data, dlc);
	case 0x3d8: return unpack_can_0x3d8_MCU_locationStatus(&can_0x3d8_MCU_locationStatus_data, data, dlc);
	case 0x488: return unpack_can_0x488_DAS_steeringControl(&can_0x488_DAS_steeringControl_data, data, dlc);
	default: break; 
	}
	return -1; 
}

int pack_message(unsigned id, uint64_t *data)
{
	switch(id) {
	case 0x003: return pack_can_0x003_STW_ANGL_STAT(&can_0x003_STW_ANGL_STAT_data, data);
	case 0x00e: return pack_can_0x00e_STW_ANGLHP_STAT(&can_0x00e_STW_ANGLHP_STAT_data, data);
	case 0x045: return pack_can_0x045_STW_ACTN_RQ(&can_0x045_STW_ACTN_RQ_data, data);
	case 0x06d: return pack_can_0x06d_SBW_RQ_SCCM(&can_0x06d_SBW_RQ_SCCM_data, data);
	case 0x101: return pack_can_0x101_GTW_epasControl(&can_0x101_GTW_epasControl_data, data);
	case 0x108: return pack_can_0x108_DI_torque1(&can_0x108_DI_torque1_data, data);
	case 0x118: return pack_can_0x118_DI_torque2(&can_0x118_DI_torque2_data, data);
	case 0x135: return pack_can_0x135_ESP_135h(&can_0x135_ESP_135h_data, data);
	case 0x155: return pack_can_0x155_ESP_B(&can_0x155_ESP_B_data, data);
	case 0x214: return pack_can_0x214_EPB_epasControl(&can_0x214_EPB_epasControl_data, data);
	case 0x283: return pack_can_0x283_BODY_R1(&can_0x283_BODY_R1_data, data);
	case 0x2f8: return pack_can_0x2f8_MCU_gpsVehicleSpeed(&can_0x2f8_MCU_gpsVehicleSpeed_data, data);
	case 0x318: return pack_can_0x318_GTW_carState(&can_0x318_GTW_carState_data, data);
	case 0x348: return pack_can_0x348_GTW_status(&can_0x348_GTW_status_data, data);
	case 0x368: return pack_can_0x368_DI_state(&can_0x368_DI_state_data, data);
	case 0x370: return pack_can_0x370_EPAS_sysStatus(&can_0x370_EPAS_sysStatus_data, data);
	case 0x388: return pack_can_0x388_MCU_clusterBacklightRequest(&can_0x388_MCU_clusterBacklightRequest_data, data);
	case 0x3d8: return pack_can_0x3d8_MCU_locationStatus(&can_0x3d8_MCU_locationStatus_data, data);
	case 0x488: return pack_can_0x488_DAS_steeringControl(&can_0x488_DAS_steeringControl_data, data);
	default: break; 
	}
	return -1; 
}

int print_message(unsigned id, FILE* data)
{
	switch(id) {
	case 0x003: return print_can_0x003_STW_ANGL_STAT(&can_0x003_STW_ANGL_STAT_data, data);
	case 0x00e: return print_can_0x00e_STW_ANGLHP_STAT(&can_0x00e_STW_ANGLHP_STAT_data, data);
	case 0x045: return print_can_0x045_STW_ACTN_RQ(&can_0x045_STW_ACTN_RQ_data, data);
	case 0x06d: return print_can_0x06d_SBW_RQ_SCCM(&can_0x06d_SBW_RQ_SCCM_data, data);
	case 0x101: return print_can_0x101_GTW_epasControl(&can_0x101_GTW_epasControl_data, data);
	case 0x108: return print_can_0x108_DI_torque1(&can_0x108_DI_torque1_data, data);
	case 0x118: return print_can_0x118_DI_torque2(&can_0x118_DI_torque2_data, data);
	case 0x135: return print_can_0x135_ESP_135h(&can_0x135_ESP_135h_data, data);
	case 0x155: return print_can_0x155_ESP_B(&can_0x155_ESP_B_data, data);
	case 0x214: return print_can_0x214_EPB_epasControl(&can_0x214_EPB_epasControl_data, data);
	case 0x283: return print_can_0x283_BODY_R1(&can_0x283_BODY_R1_data, data);
	case 0x2f8: return print_can_0x2f8_MCU_gpsVehicleSpeed(&can_0x2f8_MCU_gpsVehicleSpeed_data, data);
	case 0x318: return print_can_0x318_GTW_carState(&can_0x318_GTW_carState_data, data);
	case 0x348: return print_can_0x348_GTW_status(&can_0x348_GTW_status_data, data);
	case 0x368: return print_can_0x368_DI_state(&can_0x368_DI_state_data, data);
	case 0x370: return print_can_0x370_EPAS_sysStatus(&can_0x370_EPAS_sysStatus_data, data);
	case 0x388: return print_can_0x388_MCU_clusterBacklightRequest(&can_0x388_MCU_clusterBacklightRequest_data, data);
	case 0x3d8: return print_can_0x3d8_MCU_locationStatus(&can_0x3d8_MCU_locationStatus_data, data);
	case 0x488: return print_can_0x488_DAS_steeringControl(&can_0x488_DAS_steeringControl_data, data);
	default: break; 
	}
	return -1; 
}

int pack_can_0x003_STW_ANGL_STAT(can_0x003_STW_ANGL_STAT_t *pack, uint64_t *data)
{
	register uint64_t x;
	register uint64_t m = 0;
	/* StW_Angl: start-bit 5, length 14, endianess motorola, scaling 0.5, offset -2048 */
	x = ((uint16_t)(pack->StW_Angl)) & 0x3fff;
	x <<= 48; 
	m |= x;
	/* StW_AnglSpd: start-bit 21, length 14, endianess motorola, scaling 0.5, offset -2048 */
	x = ((uint16_t)(pack->StW_AnglSpd)) & 0x3fff;
	x <<= 32; 
	m |= x;
	/* CRC_STW_ANGL_STAT: start-bit 63, length 8, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->CRC_STW_ANGL_STAT)) & 0xff;
	m |= x;
	/* MC_STW_ANGL_STAT: start-bit 55, length 4, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->MC_STW_ANGL_STAT)) & 0xf;
	x <<= 12; 
	m |= x;
	/* StW_AnglSens_Stat: start-bit 33, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_AnglSens_Stat)) & 0x3;
	x <<= 24; 
	m |= x;
	/* StW_AnglSens_Id: start-bit 35, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_AnglSens_Id)) & 0x3;
	x <<= 26; 
	m |= x;
	*data = reverse_byte_order(m);
	return 0;
}

int unpack_can_0x003_STW_ANGL_STAT(can_0x003_STW_ANGL_STAT_t *unpack, uint64_t data, uint8_t dlc)
{
	register uint64_t x;
	register uint64_t m = reverse_byte_order(data);
	if (dlc < 8)
		return -1;
	/* StW_Angl: start-bit 5, length 14, endianess motorola, scaling 0.5, offset -2048 */
	x = (m >> 48) & 0x3fff;
	unpack->StW_Angl = x;
	/* StW_AnglSpd: start-bit 21, length 14, endianess motorola, scaling 0.5, offset -2048 */
	x = (m >> 32) & 0x3fff;
	unpack->StW_AnglSpd = x;
	/* CRC_STW_ANGL_STAT: start-bit 63, length 8, endianess motorola, scaling 1, offset 0 */
	x = m & 0xff;
	unpack->CRC_STW_ANGL_STAT = x;
	/* MC_STW_ANGL_STAT: start-bit 55, length 4, endianess motorola, scaling 1, offset 0 */
	x = (m >> 12) & 0xf;
	unpack->MC_STW_ANGL_STAT = x;
	/* StW_AnglSens_Stat: start-bit 33, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 24) & 0x3;
	unpack->StW_AnglSens_Stat = x;
	/* StW_AnglSens_Id: start-bit 35, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 26) & 0x3;
	unpack->StW_AnglSens_Id = x;
	return 0;
}

bool decode_can_0x003_StW_Angl(can_0x003_STW_ANGL_STAT_t *record, double *out)
{
	double rval = (double)(record->StW_Angl);
	rval *= 0.5;
	rval += -2048;
	*out = rval;
	return true;
}

bool encode_can_0x003_StW_Angl(can_0x003_STW_ANGL_STAT_t *record, double in)
{
	in += 2048;
	in *= 2;
	record->StW_Angl = in;
	return true;
}

bool decode_can_0x003_StW_AnglSpd(can_0x003_STW_ANGL_STAT_t *record, double *out)
{
	double rval = (double)(record->StW_AnglSpd);
	rval *= 0.5;
	rval += -2048;
	*out = rval;
	return true;
}

bool encode_can_0x003_StW_AnglSpd(can_0x003_STW_ANGL_STAT_t *record, double in)
{
	in += 2048;
	in *= 2;
	record->StW_AnglSpd = in;
	return true;
}

bool decode_can_0x003_CRC_STW_ANGL_STAT(can_0x003_STW_ANGL_STAT_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->CRC_STW_ANGL_STAT);
	*out = rval;
	return true;
}

bool encode_can_0x003_CRC_STW_ANGL_STAT(can_0x003_STW_ANGL_STAT_t *record, uint8_t in)
{
	record->CRC_STW_ANGL_STAT = in;
	return true;
}

bool decode_can_0x003_MC_STW_ANGL_STAT(can_0x003_STW_ANGL_STAT_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->MC_STW_ANGL_STAT);
	*out = rval;
	return true;
}

bool encode_can_0x003_MC_STW_ANGL_STAT(can_0x003_STW_ANGL_STAT_t *record, uint8_t in)
{
	record->MC_STW_ANGL_STAT = in;
	return true;
}

bool decode_can_0x003_StW_AnglSens_Stat(can_0x003_STW_ANGL_STAT_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_AnglSens_Stat);
	*out = rval;
	return true;
}

bool encode_can_0x003_StW_AnglSens_Stat(can_0x003_STW_ANGL_STAT_t *record, uint8_t in)
{
	record->StW_AnglSens_Stat = in;
	return true;
}

bool decode_can_0x003_StW_AnglSens_Id(can_0x003_STW_ANGL_STAT_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_AnglSens_Id);
	*out = rval;
	return true;
}

bool encode_can_0x003_StW_AnglSens_Id(can_0x003_STW_ANGL_STAT_t *record, uint8_t in)
{
	record->StW_AnglSens_Id = in;
	return true;
}

int print_can_0x003_STW_ANGL_STAT(can_0x003_STW_ANGL_STAT_t *print, FILE *data)
{
	int r = 0;
	r = phelper(r, fprintf(data, "StW_Angl = (wire: %.0f)\n", (double)(print->StW_Angl)));
	r = phelper(r, fprintf(data, "StW_AnglSpd = (wire: %.0f)\n", (double)(print->StW_AnglSpd)));
	r = phelper(r, fprintf(data, "CRC_STW_ANGL_STAT = (wire: %.0f)\n", (double)(print->CRC_STW_ANGL_STAT)));
	r = phelper(r, fprintf(data, "MC_STW_ANGL_STAT = (wire: %.0f)\n", (double)(print->MC_STW_ANGL_STAT)));
	r = phelper(r, fprintf(data, "StW_AnglSens_Stat = (wire: %.0f)\n", (double)(print->StW_AnglSens_Stat)));
	r = phelper(r, fprintf(data, "StW_AnglSens_Id = (wire: %.0f)\n", (double)(print->StW_AnglSens_Id)));
	return r;
}

int pack_can_0x00e_STW_ANGLHP_STAT(can_0x00e_STW_ANGLHP_STAT_t *pack, uint64_t *data)
{
	register uint64_t x;
	register uint64_t m = 0;
	/* StW_AnglHP: start-bit 5, length 14, endianess motorola, scaling 0.1, offset -819.2 */
	x = ((uint16_t)(pack->StW_AnglHP)) & 0x3fff;
	x <<= 48; 
	m |= x;
	/* StW_AnglHP_Spd: start-bit 21, length 14, endianess motorola, scaling 0.5, offset -4096 */
	x = ((uint16_t)(pack->StW_AnglHP_Spd)) & 0x3fff;
	x <<= 32; 
	m |= x;
	/* CRC_STW_ANGLHP_STAT: start-bit 63, length 8, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->CRC_STW_ANGLHP_STAT)) & 0xff;
	m |= x;
	/* MC_STW_ANGLHP_STAT: start-bit 55, length 4, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->MC_STW_ANGLHP_STAT)) & 0xf;
	x <<= 12; 
	m |= x;
	/* StW_AnglHP_Sens_Stat: start-bit 33, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_AnglHP_Sens_Stat)) & 0x3;
	x <<= 24; 
	m |= x;
	/* StW_AnglHP_Sens_Id: start-bit 35, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_AnglHP_Sens_Id)) & 0x3;
	x <<= 26; 
	m |= x;
	*data = reverse_byte_order(m);
	return 0;
}

int unpack_can_0x00e_STW_ANGLHP_STAT(can_0x00e_STW_ANGLHP_STAT_t *unpack, uint64_t data, uint8_t dlc)
{
	register uint64_t x;
	register uint64_t m = reverse_byte_order(data);
	if (dlc < 8)
		return -1;
	/* StW_AnglHP: start-bit 5, length 14, endianess motorola, scaling 0.1, offset -819.2 */
	x = (m >> 48) & 0x3fff;
	unpack->StW_AnglHP = x;
	/* StW_AnglHP_Spd: start-bit 21, length 14, endianess motorola, scaling 0.5, offset -4096 */
	x = (m >> 32) & 0x3fff;
	unpack->StW_AnglHP_Spd = x;
	/* CRC_STW_ANGLHP_STAT: start-bit 63, length 8, endianess motorola, scaling 1, offset 0 */
	x = m & 0xff;
	unpack->CRC_STW_ANGLHP_STAT = x;
	/* MC_STW_ANGLHP_STAT: start-bit 55, length 4, endianess motorola, scaling 1, offset 0 */
	x = (m >> 12) & 0xf;
	unpack->MC_STW_ANGLHP_STAT = x;
	/* StW_AnglHP_Sens_Stat: start-bit 33, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 24) & 0x3;
	unpack->StW_AnglHP_Sens_Stat = x;
	/* StW_AnglHP_Sens_Id: start-bit 35, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 26) & 0x3;
	unpack->StW_AnglHP_Sens_Id = x;
	return 0;
}

bool decode_can_0x00e_StW_AnglHP(can_0x00e_STW_ANGLHP_STAT_t *record, double *out)
{
	double rval = (double)(record->StW_AnglHP);
	rval *= 0.1;
	rval += -819.2;
	if (rval <= 819) {
		*out = rval;
		return true;
	} else {
		*out = (double)0;
		return false;
	}
}

bool encode_can_0x00e_StW_AnglHP(can_0x00e_STW_ANGLHP_STAT_t *record, double in)
{
	record->StW_AnglHP = 0;
	if (in > 819)
		return false;
	in += 819.2;
	in *= 10;
	record->StW_AnglHP = in;
	return true;
}

bool decode_can_0x00e_StW_AnglHP_Spd(can_0x00e_STW_ANGLHP_STAT_t *record, double *out)
{
	double rval = (double)(record->StW_AnglHP_Spd);
	rval *= 0.5;
	rval += -4096;
	if (rval <= 4095.5) {
		*out = rval;
		return true;
	} else {
		*out = (double)0;
		return false;
	}
}

bool encode_can_0x00e_StW_AnglHP_Spd(can_0x00e_STW_ANGLHP_STAT_t *record, double in)
{
	record->StW_AnglHP_Spd = 0;
	if (in > 4095.5)
		return false;
	in += 4096;
	in *= 2;
	record->StW_AnglHP_Spd = in;
	return true;
}

bool decode_can_0x00e_CRC_STW_ANGLHP_STAT(can_0x00e_STW_ANGLHP_STAT_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->CRC_STW_ANGLHP_STAT);
	*out = rval;
	return true;
}

bool encode_can_0x00e_CRC_STW_ANGLHP_STAT(can_0x00e_STW_ANGLHP_STAT_t *record, uint8_t in)
{
	record->CRC_STW_ANGLHP_STAT = in;
	return true;
}

bool decode_can_0x00e_MC_STW_ANGLHP_STAT(can_0x00e_STW_ANGLHP_STAT_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->MC_STW_ANGLHP_STAT);
	*out = rval;
	return true;
}

bool encode_can_0x00e_MC_STW_ANGLHP_STAT(can_0x00e_STW_ANGLHP_STAT_t *record, uint8_t in)
{
	record->MC_STW_ANGLHP_STAT = in;
	return true;
}

bool decode_can_0x00e_StW_AnglHP_Sens_Stat(can_0x00e_STW_ANGLHP_STAT_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_AnglHP_Sens_Stat);
	*out = rval;
	return true;
}

bool encode_can_0x00e_StW_AnglHP_Sens_Stat(can_0x00e_STW_ANGLHP_STAT_t *record, uint8_t in)
{
	record->StW_AnglHP_Sens_Stat = in;
	return true;
}

bool decode_can_0x00e_StW_AnglHP_Sens_Id(can_0x00e_STW_ANGLHP_STAT_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_AnglHP_Sens_Id);
	*out = rval;
	return true;
}

bool encode_can_0x00e_StW_AnglHP_Sens_Id(can_0x00e_STW_ANGLHP_STAT_t *record, uint8_t in)
{
	record->StW_AnglHP_Sens_Id = in;
	return true;
}

int print_can_0x00e_STW_ANGLHP_STAT(can_0x00e_STW_ANGLHP_STAT_t *print, FILE *data)
{
	int r = 0;
	r = phelper(r, fprintf(data, "StW_AnglHP = (wire: %.0f)\n", (double)(print->StW_AnglHP)));
	r = phelper(r, fprintf(data, "StW_AnglHP_Spd = (wire: %.0f)\n", (double)(print->StW_AnglHP_Spd)));
	r = phelper(r, fprintf(data, "CRC_STW_ANGLHP_STAT = (wire: %.0f)\n", (double)(print->CRC_STW_ANGLHP_STAT)));
	r = phelper(r, fprintf(data, "MC_STW_ANGLHP_STAT = (wire: %.0f)\n", (double)(print->MC_STW_ANGLHP_STAT)));
	r = phelper(r, fprintf(data, "StW_AnglHP_Sens_Stat = (wire: %.0f)\n", (double)(print->StW_AnglHP_Sens_Stat)));
	r = phelper(r, fprintf(data, "StW_AnglHP_Sens_Id = (wire: %.0f)\n", (double)(print->StW_AnglHP_Sens_Id)));
	return r;
}

int pack_can_0x045_STW_ACTN_RQ(can_0x045_STW_ACTN_RQ_t *pack, uint64_t *data)
{
	register uint64_t x;
	register uint64_t i = 0;
	/* DTR_Dist_Rq: start-bit 8, length 8, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DTR_Dist_Rq)) & 0xff;
	x <<= 8; 
	i |= x;
	/* CRC_STW_ACTN_RQ: start-bit 56, length 8, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->CRC_STW_ACTN_RQ)) & 0xff;
	x <<= 56; 
	i |= x;
	/* SpdCtrlLvr_Stat: start-bit 0, length 6, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->SpdCtrlLvr_Stat)) & 0x3f;
	i |= x;
	/* MC_STW_ACTN_RQ: start-bit 52, length 4, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->MC_STW_ACTN_RQ)) & 0xf;
	x <<= 52; 
	i |= x;
	/* StW_Lvr_Stat: start-bit 24, length 3, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_Lvr_Stat)) & 0x7;
	x <<= 24; 
	i |= x;
	/* WprSw6Posn: start-bit 48, length 3, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->WprSw6Posn)) & 0x7;
	x <<= 48; 
	i |= x;
	/* TurnIndLvr_Stat: start-bit 16, length 2, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->TurnIndLvr_Stat)) & 0x3;
	x <<= 16; 
	i |= x;
	/* HiBmLvr_Stat: start-bit 18, length 2, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->HiBmLvr_Stat)) & 0x3;
	x <<= 18; 
	i |= x;
	/* WprWashSw_Psd: start-bit 20, length 2, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->WprWashSw_Psd)) & 0x3;
	x <<= 20; 
	i |= x;
	/* WprWash_R_Sw_Posn_V2: start-bit 22, length 2, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->WprWash_R_Sw_Posn_V2)) & 0x3;
	x <<= 22; 
	i |= x;
	/* StW_Cond_Psd: start-bit 28, length 2, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_Cond_Psd)) & 0x3;
	x <<= 28; 
	i |= x;
	/* HrnSw_Psd: start-bit 30, length 2, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->HrnSw_Psd)) & 0x3;
	x <<= 30; 
	i |= x;
	/* VSL_Enbl_Rq: start-bit 6, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->VSL_Enbl_Rq)) & 0x1;
	x <<= 6; 
	i |= x;
	/* SpdCtrlLvrStat_Inv: start-bit 7, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->SpdCtrlLvrStat_Inv)) & 0x1;
	x <<= 7; 
	i |= x;
	/* StW_Cond_Flt: start-bit 27, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_Cond_Flt)) & 0x1;
	x <<= 27; 
	i |= x;
	/* StW_Sw00_Psd: start-bit 32, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_Sw00_Psd)) & 0x1;
	x <<= 32; 
	i |= x;
	/* StW_Sw01_Psd: start-bit 33, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_Sw01_Psd)) & 0x1;
	x <<= 33; 
	i |= x;
	/* StW_Sw02_Psd: start-bit 34, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_Sw02_Psd)) & 0x1;
	x <<= 34; 
	i |= x;
	/* StW_Sw03_Psd: start-bit 35, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_Sw03_Psd)) & 0x1;
	x <<= 35; 
	i |= x;
	/* StW_Sw04_Psd: start-bit 36, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_Sw04_Psd)) & 0x1;
	x <<= 36; 
	i |= x;
	/* StW_Sw05_Psd: start-bit 37, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_Sw05_Psd)) & 0x1;
	x <<= 37; 
	i |= x;
	/* StW_Sw06_Psd: start-bit 38, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_Sw06_Psd)) & 0x1;
	x <<= 38; 
	i |= x;
	/* StW_Sw07_Psd: start-bit 39, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_Sw07_Psd)) & 0x1;
	x <<= 39; 
	i |= x;
	/* StW_Sw08_Psd: start-bit 40, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_Sw08_Psd)) & 0x1;
	x <<= 40; 
	i |= x;
	/* StW_Sw09_Psd: start-bit 41, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_Sw09_Psd)) & 0x1;
	x <<= 41; 
	i |= x;
	/* StW_Sw10_Psd: start-bit 42, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_Sw10_Psd)) & 0x1;
	x <<= 42; 
	i |= x;
	/* StW_Sw11_Psd: start-bit 43, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_Sw11_Psd)) & 0x1;
	x <<= 43; 
	i |= x;
	/* StW_Sw12_Psd: start-bit 44, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_Sw12_Psd)) & 0x1;
	x <<= 44; 
	i |= x;
	/* StW_Sw13_Psd: start-bit 45, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_Sw13_Psd)) & 0x1;
	x <<= 45; 
	i |= x;
	/* StW_Sw14_Psd: start-bit 46, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_Sw14_Psd)) & 0x1;
	x <<= 46; 
	i |= x;
	/* StW_Sw15_Psd: start-bit 47, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_Sw15_Psd)) & 0x1;
	x <<= 47; 
	i |= x;
	*data = (i);
	return 0;
}

int unpack_can_0x045_STW_ACTN_RQ(can_0x045_STW_ACTN_RQ_t *unpack, uint64_t data, uint8_t dlc)
{
	register uint64_t x;
	register uint64_t i = (data);
	if (dlc < 8)
		return -1;
	/* DTR_Dist_Rq: start-bit 8, length 8, endianess intel, scaling 1, offset 0 */
	x = (i >> 8) & 0xff;
	unpack->DTR_Dist_Rq = x;
	/* CRC_STW_ACTN_RQ: start-bit 56, length 8, endianess intel, scaling 1, offset 0 */
	x = (i >> 56) & 0xff;
	unpack->CRC_STW_ACTN_RQ = x;
	/* SpdCtrlLvr_Stat: start-bit 0, length 6, endianess intel, scaling 1, offset 0 */
	x = i & 0x3f;
	unpack->SpdCtrlLvr_Stat = x;
	/* MC_STW_ACTN_RQ: start-bit 52, length 4, endianess intel, scaling 1, offset 0 */
	x = (i >> 52) & 0xf;
	unpack->MC_STW_ACTN_RQ = x;
	/* StW_Lvr_Stat: start-bit 24, length 3, endianess intel, scaling 1, offset 0 */
	x = (i >> 24) & 0x7;
	unpack->StW_Lvr_Stat = x;
	/* WprSw6Posn: start-bit 48, length 3, endianess intel, scaling 1, offset 0 */
	x = (i >> 48) & 0x7;
	unpack->WprSw6Posn = x;
	/* TurnIndLvr_Stat: start-bit 16, length 2, endianess intel, scaling 1, offset 0 */
	x = (i >> 16) & 0x3;
	unpack->TurnIndLvr_Stat = x;
	/* HiBmLvr_Stat: start-bit 18, length 2, endianess intel, scaling 1, offset 0 */
	x = (i >> 18) & 0x3;
	unpack->HiBmLvr_Stat = x;
	/* WprWashSw_Psd: start-bit 20, length 2, endianess intel, scaling 1, offset 0 */
	x = (i >> 20) & 0x3;
	unpack->WprWashSw_Psd = x;
	/* WprWash_R_Sw_Posn_V2: start-bit 22, length 2, endianess intel, scaling 1, offset 0 */
	x = (i >> 22) & 0x3;
	unpack->WprWash_R_Sw_Posn_V2 = x;
	/* StW_Cond_Psd: start-bit 28, length 2, endianess intel, scaling 1, offset 0 */
	x = (i >> 28) & 0x3;
	unpack->StW_Cond_Psd = x;
	/* HrnSw_Psd: start-bit 30, length 2, endianess intel, scaling 1, offset 0 */
	x = (i >> 30) & 0x3;
	unpack->HrnSw_Psd = x;
	/* VSL_Enbl_Rq: start-bit 6, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 6) & 0x1;
	unpack->VSL_Enbl_Rq = x;
	/* SpdCtrlLvrStat_Inv: start-bit 7, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 7) & 0x1;
	unpack->SpdCtrlLvrStat_Inv = x;
	/* StW_Cond_Flt: start-bit 27, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 27) & 0x1;
	unpack->StW_Cond_Flt = x;
	/* StW_Sw00_Psd: start-bit 32, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 32) & 0x1;
	unpack->StW_Sw00_Psd = x;
	/* StW_Sw01_Psd: start-bit 33, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 33) & 0x1;
	unpack->StW_Sw01_Psd = x;
	/* StW_Sw02_Psd: start-bit 34, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 34) & 0x1;
	unpack->StW_Sw02_Psd = x;
	/* StW_Sw03_Psd: start-bit 35, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 35) & 0x1;
	unpack->StW_Sw03_Psd = x;
	/* StW_Sw04_Psd: start-bit 36, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 36) & 0x1;
	unpack->StW_Sw04_Psd = x;
	/* StW_Sw05_Psd: start-bit 37, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 37) & 0x1;
	unpack->StW_Sw05_Psd = x;
	/* StW_Sw06_Psd: start-bit 38, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 38) & 0x1;
	unpack->StW_Sw06_Psd = x;
	/* StW_Sw07_Psd: start-bit 39, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 39) & 0x1;
	unpack->StW_Sw07_Psd = x;
	/* StW_Sw08_Psd: start-bit 40, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 40) & 0x1;
	unpack->StW_Sw08_Psd = x;
	/* StW_Sw09_Psd: start-bit 41, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 41) & 0x1;
	unpack->StW_Sw09_Psd = x;
	/* StW_Sw10_Psd: start-bit 42, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 42) & 0x1;
	unpack->StW_Sw10_Psd = x;
	/* StW_Sw11_Psd: start-bit 43, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 43) & 0x1;
	unpack->StW_Sw11_Psd = x;
	/* StW_Sw12_Psd: start-bit 44, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 44) & 0x1;
	unpack->StW_Sw12_Psd = x;
	/* StW_Sw13_Psd: start-bit 45, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 45) & 0x1;
	unpack->StW_Sw13_Psd = x;
	/* StW_Sw14_Psd: start-bit 46, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 46) & 0x1;
	unpack->StW_Sw14_Psd = x;
	/* StW_Sw15_Psd: start-bit 47, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 47) & 0x1;
	unpack->StW_Sw15_Psd = x;
	return 0;
}

bool decode_can_0x045_DTR_Dist_Rq(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DTR_Dist_Rq);
	if (rval <= 200) {
		*out = rval;
		return true;
	} else {
		*out = (uint8_t)0;
		return false;
	}
}

bool encode_can_0x045_DTR_Dist_Rq(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->DTR_Dist_Rq = 0;
	if (in > 200)
		return false;
	record->DTR_Dist_Rq = in;
	return true;
}

bool decode_can_0x045_CRC_STW_ACTN_RQ(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->CRC_STW_ACTN_RQ);
	*out = rval;
	return true;
}

bool encode_can_0x045_CRC_STW_ACTN_RQ(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->CRC_STW_ACTN_RQ = in;
	return true;
}

bool decode_can_0x045_SpdCtrlLvr_Stat(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->SpdCtrlLvr_Stat);
	*out = rval;
	return true;
}

bool encode_can_0x045_SpdCtrlLvr_Stat(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->SpdCtrlLvr_Stat = in;
	return true;
}

bool decode_can_0x045_MC_STW_ACTN_RQ(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->MC_STW_ACTN_RQ);
	*out = rval;
	return true;
}

bool encode_can_0x045_MC_STW_ACTN_RQ(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->MC_STW_ACTN_RQ = in;
	return true;
}

bool decode_can_0x045_StW_Lvr_Stat(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_Lvr_Stat);
	*out = rval;
	return true;
}

bool encode_can_0x045_StW_Lvr_Stat(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->StW_Lvr_Stat = in;
	return true;
}

bool decode_can_0x045_WprSw6Posn(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->WprSw6Posn);
	*out = rval;
	return true;
}

bool encode_can_0x045_WprSw6Posn(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->WprSw6Posn = in;
	return true;
}

bool decode_can_0x045_TurnIndLvr_Stat(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->TurnIndLvr_Stat);
	*out = rval;
	return true;
}

bool encode_can_0x045_TurnIndLvr_Stat(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->TurnIndLvr_Stat = in;
	return true;
}

bool decode_can_0x045_HiBmLvr_Stat(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->HiBmLvr_Stat);
	*out = rval;
	return true;
}

bool encode_can_0x045_HiBmLvr_Stat(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->HiBmLvr_Stat = in;
	return true;
}

bool decode_can_0x045_WprWashSw_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->WprWashSw_Psd);
	*out = rval;
	return true;
}

bool encode_can_0x045_WprWashSw_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->WprWashSw_Psd = in;
	return true;
}

bool decode_can_0x045_WprWash_R_Sw_Posn_V2(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->WprWash_R_Sw_Posn_V2);
	*out = rval;
	return true;
}

bool encode_can_0x045_WprWash_R_Sw_Posn_V2(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->WprWash_R_Sw_Posn_V2 = in;
	return true;
}

bool decode_can_0x045_StW_Cond_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_Cond_Psd);
	*out = rval;
	return true;
}

bool encode_can_0x045_StW_Cond_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->StW_Cond_Psd = in;
	return true;
}

bool decode_can_0x045_HrnSw_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->HrnSw_Psd);
	*out = rval;
	return true;
}

bool encode_can_0x045_HrnSw_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->HrnSw_Psd = in;
	return true;
}

bool decode_can_0x045_VSL_Enbl_Rq(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->VSL_Enbl_Rq);
	*out = rval;
	return true;
}

bool encode_can_0x045_VSL_Enbl_Rq(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->VSL_Enbl_Rq = in;
	return true;
}

bool decode_can_0x045_SpdCtrlLvrStat_Inv(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->SpdCtrlLvrStat_Inv);
	*out = rval;
	return true;
}

bool encode_can_0x045_SpdCtrlLvrStat_Inv(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->SpdCtrlLvrStat_Inv = in;
	return true;
}

bool decode_can_0x045_StW_Cond_Flt(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_Cond_Flt);
	*out = rval;
	return true;
}

bool encode_can_0x045_StW_Cond_Flt(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->StW_Cond_Flt = in;
	return true;
}

bool decode_can_0x045_StW_Sw00_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_Sw00_Psd);
	*out = rval;
	return true;
}

bool encode_can_0x045_StW_Sw00_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->StW_Sw00_Psd = in;
	return true;
}

bool decode_can_0x045_StW_Sw01_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_Sw01_Psd);
	*out = rval;
	return true;
}

bool encode_can_0x045_StW_Sw01_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->StW_Sw01_Psd = in;
	return true;
}

bool decode_can_0x045_StW_Sw02_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_Sw02_Psd);
	*out = rval;
	return true;
}

bool encode_can_0x045_StW_Sw02_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->StW_Sw02_Psd = in;
	return true;
}

bool decode_can_0x045_StW_Sw03_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_Sw03_Psd);
	*out = rval;
	return true;
}

bool encode_can_0x045_StW_Sw03_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->StW_Sw03_Psd = in;
	return true;
}

bool decode_can_0x045_StW_Sw04_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_Sw04_Psd);
	*out = rval;
	return true;
}

bool encode_can_0x045_StW_Sw04_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->StW_Sw04_Psd = in;
	return true;
}

bool decode_can_0x045_StW_Sw05_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_Sw05_Psd);
	*out = rval;
	return true;
}

bool encode_can_0x045_StW_Sw05_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->StW_Sw05_Psd = in;
	return true;
}

bool decode_can_0x045_StW_Sw06_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_Sw06_Psd);
	*out = rval;
	return true;
}

bool encode_can_0x045_StW_Sw06_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->StW_Sw06_Psd = in;
	return true;
}

bool decode_can_0x045_StW_Sw07_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_Sw07_Psd);
	*out = rval;
	return true;
}

bool encode_can_0x045_StW_Sw07_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->StW_Sw07_Psd = in;
	return true;
}

bool decode_can_0x045_StW_Sw08_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_Sw08_Psd);
	*out = rval;
	return true;
}

bool encode_can_0x045_StW_Sw08_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->StW_Sw08_Psd = in;
	return true;
}

bool decode_can_0x045_StW_Sw09_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_Sw09_Psd);
	*out = rval;
	return true;
}

bool encode_can_0x045_StW_Sw09_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->StW_Sw09_Psd = in;
	return true;
}

bool decode_can_0x045_StW_Sw10_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_Sw10_Psd);
	*out = rval;
	return true;
}

bool encode_can_0x045_StW_Sw10_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->StW_Sw10_Psd = in;
	return true;
}

bool decode_can_0x045_StW_Sw11_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_Sw11_Psd);
	*out = rval;
	return true;
}

bool encode_can_0x045_StW_Sw11_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->StW_Sw11_Psd = in;
	return true;
}

bool decode_can_0x045_StW_Sw12_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_Sw12_Psd);
	*out = rval;
	return true;
}

bool encode_can_0x045_StW_Sw12_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->StW_Sw12_Psd = in;
	return true;
}

bool decode_can_0x045_StW_Sw13_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_Sw13_Psd);
	*out = rval;
	return true;
}

bool encode_can_0x045_StW_Sw13_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->StW_Sw13_Psd = in;
	return true;
}

bool decode_can_0x045_StW_Sw14_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_Sw14_Psd);
	*out = rval;
	return true;
}

bool encode_can_0x045_StW_Sw14_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->StW_Sw14_Psd = in;
	return true;
}

bool decode_can_0x045_StW_Sw15_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_Sw15_Psd);
	*out = rval;
	return true;
}

bool encode_can_0x045_StW_Sw15_Psd(can_0x045_STW_ACTN_RQ_t *record, uint8_t in)
{
	record->StW_Sw15_Psd = in;
	return true;
}

int print_can_0x045_STW_ACTN_RQ(can_0x045_STW_ACTN_RQ_t *print, FILE *data)
{
	int r = 0;
	r = phelper(r, fprintf(data, "DTR_Dist_Rq = (wire: %.0f)\n", (double)(print->DTR_Dist_Rq)));
	r = phelper(r, fprintf(data, "CRC_STW_ACTN_RQ = (wire: %.0f)\n", (double)(print->CRC_STW_ACTN_RQ)));
	r = phelper(r, fprintf(data, "SpdCtrlLvr_Stat = (wire: %.0f)\n", (double)(print->SpdCtrlLvr_Stat)));
	r = phelper(r, fprintf(data, "MC_STW_ACTN_RQ = (wire: %.0f)\n", (double)(print->MC_STW_ACTN_RQ)));
	r = phelper(r, fprintf(data, "StW_Lvr_Stat = (wire: %.0f)\n", (double)(print->StW_Lvr_Stat)));
	r = phelper(r, fprintf(data, "WprSw6Posn = (wire: %.0f)\n", (double)(print->WprSw6Posn)));
	r = phelper(r, fprintf(data, "TurnIndLvr_Stat = (wire: %.0f)\n", (double)(print->TurnIndLvr_Stat)));
	r = phelper(r, fprintf(data, "HiBmLvr_Stat = (wire: %.0f)\n", (double)(print->HiBmLvr_Stat)));
	r = phelper(r, fprintf(data, "WprWashSw_Psd = (wire: %.0f)\n", (double)(print->WprWashSw_Psd)));
	r = phelper(r, fprintf(data, "WprWash_R_Sw_Posn_V2 = (wire: %.0f)\n", (double)(print->WprWash_R_Sw_Posn_V2)));
	r = phelper(r, fprintf(data, "StW_Cond_Psd = (wire: %.0f)\n", (double)(print->StW_Cond_Psd)));
	r = phelper(r, fprintf(data, "HrnSw_Psd = (wire: %.0f)\n", (double)(print->HrnSw_Psd)));
	r = phelper(r, fprintf(data, "VSL_Enbl_Rq = (wire: %.0f)\n", (double)(print->VSL_Enbl_Rq)));
	r = phelper(r, fprintf(data, "SpdCtrlLvrStat_Inv = (wire: %.0f)\n", (double)(print->SpdCtrlLvrStat_Inv)));
	r = phelper(r, fprintf(data, "StW_Cond_Flt = (wire: %.0f)\n", (double)(print->StW_Cond_Flt)));
	r = phelper(r, fprintf(data, "StW_Sw00_Psd = (wire: %.0f)\n", (double)(print->StW_Sw00_Psd)));
	r = phelper(r, fprintf(data, "StW_Sw01_Psd = (wire: %.0f)\n", (double)(print->StW_Sw01_Psd)));
	r = phelper(r, fprintf(data, "StW_Sw02_Psd = (wire: %.0f)\n", (double)(print->StW_Sw02_Psd)));
	r = phelper(r, fprintf(data, "StW_Sw03_Psd = (wire: %.0f)\n", (double)(print->StW_Sw03_Psd)));
	r = phelper(r, fprintf(data, "StW_Sw04_Psd = (wire: %.0f)\n", (double)(print->StW_Sw04_Psd)));
	r = phelper(r, fprintf(data, "StW_Sw05_Psd = (wire: %.0f)\n", (double)(print->StW_Sw05_Psd)));
	r = phelper(r, fprintf(data, "StW_Sw06_Psd = (wire: %.0f)\n", (double)(print->StW_Sw06_Psd)));
	r = phelper(r, fprintf(data, "StW_Sw07_Psd = (wire: %.0f)\n", (double)(print->StW_Sw07_Psd)));
	r = phelper(r, fprintf(data, "StW_Sw08_Psd = (wire: %.0f)\n", (double)(print->StW_Sw08_Psd)));
	r = phelper(r, fprintf(data, "StW_Sw09_Psd = (wire: %.0f)\n", (double)(print->StW_Sw09_Psd)));
	r = phelper(r, fprintf(data, "StW_Sw10_Psd = (wire: %.0f)\n", (double)(print->StW_Sw10_Psd)));
	r = phelper(r, fprintf(data, "StW_Sw11_Psd = (wire: %.0f)\n", (double)(print->StW_Sw11_Psd)));
	r = phelper(r, fprintf(data, "StW_Sw12_Psd = (wire: %.0f)\n", (double)(print->StW_Sw12_Psd)));
	r = phelper(r, fprintf(data, "StW_Sw13_Psd = (wire: %.0f)\n", (double)(print->StW_Sw13_Psd)));
	r = phelper(r, fprintf(data, "StW_Sw14_Psd = (wire: %.0f)\n", (double)(print->StW_Sw14_Psd)));
	r = phelper(r, fprintf(data, "StW_Sw15_Psd = (wire: %.0f)\n", (double)(print->StW_Sw15_Psd)));
	return r;
}

int pack_can_0x06d_SBW_RQ_SCCM(can_0x06d_SBW_RQ_SCCM_t *pack, uint64_t *data)
{
	register uint64_t x;
	register uint64_t i = 0;
	/* CRC_SBW_RQ_SCCM: start-bit 24, length 8, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->CRC_SBW_RQ_SCCM)) & 0xff;
	x <<= 24; 
	i |= x;
	/* TSL_RND_Posn_StW: start-bit 8, length 4, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->TSL_RND_Posn_StW)) & 0xf;
	x <<= 8; 
	i |= x;
	/* MC_SBW_RQ_SCCM: start-bit 20, length 4, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->MC_SBW_RQ_SCCM)) & 0xf;
	x <<= 20; 
	i |= x;
	/* StW_Sw_Stat3: start-bit 0, length 3, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_Sw_Stat3)) & 0x7;
	i |= x;
	/* MsgTxmtId: start-bit 6, length 2, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->MsgTxmtId)) & 0x3;
	x <<= 6; 
	i |= x;
	/* TSL_P_Psd_StW: start-bit 12, length 2, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->TSL_P_Psd_StW)) & 0x3;
	x <<= 12; 
	i |= x;
	*data = (i);
	return 0;
}

int unpack_can_0x06d_SBW_RQ_SCCM(can_0x06d_SBW_RQ_SCCM_t *unpack, uint64_t data, uint8_t dlc)
{
	register uint64_t x;
	register uint64_t i = (data);
	if (dlc < 4)
		return -1;
	/* CRC_SBW_RQ_SCCM: start-bit 24, length 8, endianess intel, scaling 1, offset 0 */
	x = (i >> 24) & 0xff;
	unpack->CRC_SBW_RQ_SCCM = x;
	/* TSL_RND_Posn_StW: start-bit 8, length 4, endianess intel, scaling 1, offset 0 */
	x = (i >> 8) & 0xf;
	unpack->TSL_RND_Posn_StW = x;
	/* MC_SBW_RQ_SCCM: start-bit 20, length 4, endianess intel, scaling 1, offset 0 */
	x = (i >> 20) & 0xf;
	unpack->MC_SBW_RQ_SCCM = x;
	/* StW_Sw_Stat3: start-bit 0, length 3, endianess intel, scaling 1, offset 0 */
	x = i & 0x7;
	unpack->StW_Sw_Stat3 = x;
	/* MsgTxmtId: start-bit 6, length 2, endianess intel, scaling 1, offset 0 */
	x = (i >> 6) & 0x3;
	unpack->MsgTxmtId = x;
	/* TSL_P_Psd_StW: start-bit 12, length 2, endianess intel, scaling 1, offset 0 */
	x = (i >> 12) & 0x3;
	unpack->TSL_P_Psd_StW = x;
	return 0;
}

bool decode_can_0x06d_CRC_SBW_RQ_SCCM(can_0x06d_SBW_RQ_SCCM_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->CRC_SBW_RQ_SCCM);
	*out = rval;
	return true;
}

bool encode_can_0x06d_CRC_SBW_RQ_SCCM(can_0x06d_SBW_RQ_SCCM_t *record, uint8_t in)
{
	record->CRC_SBW_RQ_SCCM = in;
	return true;
}

bool decode_can_0x06d_TSL_RND_Posn_StW(can_0x06d_SBW_RQ_SCCM_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->TSL_RND_Posn_StW);
	*out = rval;
	return true;
}

bool encode_can_0x06d_TSL_RND_Posn_StW(can_0x06d_SBW_RQ_SCCM_t *record, uint8_t in)
{
	record->TSL_RND_Posn_StW = in;
	return true;
}

bool decode_can_0x06d_MC_SBW_RQ_SCCM(can_0x06d_SBW_RQ_SCCM_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->MC_SBW_RQ_SCCM);
	*out = rval;
	return true;
}

bool encode_can_0x06d_MC_SBW_RQ_SCCM(can_0x06d_SBW_RQ_SCCM_t *record, uint8_t in)
{
	record->MC_SBW_RQ_SCCM = in;
	return true;
}

bool decode_can_0x06d_StW_Sw_Stat3(can_0x06d_SBW_RQ_SCCM_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_Sw_Stat3);
	*out = rval;
	return true;
}

bool encode_can_0x06d_StW_Sw_Stat3(can_0x06d_SBW_RQ_SCCM_t *record, uint8_t in)
{
	record->StW_Sw_Stat3 = in;
	return true;
}

bool decode_can_0x06d_MsgTxmtId(can_0x06d_SBW_RQ_SCCM_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->MsgTxmtId);
	*out = rval;
	return true;
}

bool encode_can_0x06d_MsgTxmtId(can_0x06d_SBW_RQ_SCCM_t *record, uint8_t in)
{
	record->MsgTxmtId = in;
	return true;
}

bool decode_can_0x06d_TSL_P_Psd_StW(can_0x06d_SBW_RQ_SCCM_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->TSL_P_Psd_StW);
	*out = rval;
	return true;
}

bool encode_can_0x06d_TSL_P_Psd_StW(can_0x06d_SBW_RQ_SCCM_t *record, uint8_t in)
{
	record->TSL_P_Psd_StW = in;
	return true;
}

int print_can_0x06d_SBW_RQ_SCCM(can_0x06d_SBW_RQ_SCCM_t *print, FILE *data)
{
	int r = 0;
	r = phelper(r, fprintf(data, "CRC_SBW_RQ_SCCM = (wire: %.0f)\n", (double)(print->CRC_SBW_RQ_SCCM)));
	r = phelper(r, fprintf(data, "TSL_RND_Posn_StW = (wire: %.0f)\n", (double)(print->TSL_RND_Posn_StW)));
	r = phelper(r, fprintf(data, "MC_SBW_RQ_SCCM = (wire: %.0f)\n", (double)(print->MC_SBW_RQ_SCCM)));
	r = phelper(r, fprintf(data, "StW_Sw_Stat3 = (wire: %.0f)\n", (double)(print->StW_Sw_Stat3)));
	r = phelper(r, fprintf(data, "MsgTxmtId = (wire: %.0f)\n", (double)(print->MsgTxmtId)));
	r = phelper(r, fprintf(data, "TSL_P_Psd_StW = (wire: %.0f)\n", (double)(print->TSL_P_Psd_StW)));
	return r;
}

int pack_can_0x101_GTW_epasControl(can_0x101_GTW_epasControl_t *pack, uint64_t *data)
{
	register uint64_t x;
	register uint64_t m = 0;
	/* GTW_epasControlChecksum: start-bit 23, length 8, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->GTW_epasControlChecksum)) & 0xff;
	x <<= 40; 
	m |= x;
	/* GTW_epasPowerMode: start-bit 6, length 4, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->GTW_epasPowerMode)) & 0xf;
	x <<= 59; 
	m |= x;
	/* GTW_epasControlCounter: start-bit 11, length 4, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->GTW_epasControlCounter)) & 0xf;
	x <<= 48; 
	m |= x;
	/* GTW_epasTuneRequest: start-bit 2, length 3, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->GTW_epasTuneRequest)) & 0x7;
	x <<= 56; 
	m |= x;
	/* GTW_epasControlType: start-bit 15, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->GTW_epasControlType)) & 0x3;
	x <<= 54; 
	m |= x;
	/* GTW_epasEmergencyOn: start-bit 7, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->GTW_epasEmergencyOn)) & 0x1;
	x <<= 63; 
	m |= x;
	/* GTW_epasLDWEnabled: start-bit 12, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->GTW_epasLDWEnabled)) & 0x1;
	x <<= 52; 
	m |= x;
	*data = reverse_byte_order(m);
	return 0;
}

int unpack_can_0x101_GTW_epasControl(can_0x101_GTW_epasControl_t *unpack, uint64_t data, uint8_t dlc)
{
	register uint64_t x;
	register uint64_t m = reverse_byte_order(data);
	if (dlc < 3)
		return -1;
	/* GTW_epasControlChecksum: start-bit 23, length 8, endianess motorola, scaling 1, offset 0 */
	x = (m >> 40) & 0xff;
	unpack->GTW_epasControlChecksum = x;
	/* GTW_epasPowerMode: start-bit 6, length 4, endianess motorola, scaling 1, offset 0 */
	x = (m >> 59) & 0xf;
	unpack->GTW_epasPowerMode = x;
	/* GTW_epasControlCounter: start-bit 11, length 4, endianess motorola, scaling 1, offset 0 */
	x = (m >> 48) & 0xf;
	unpack->GTW_epasControlCounter = x;
	/* GTW_epasTuneRequest: start-bit 2, length 3, endianess motorola, scaling 1, offset 0 */
	x = (m >> 56) & 0x7;
	unpack->GTW_epasTuneRequest = x;
	/* GTW_epasControlType: start-bit 15, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 54) & 0x3;
	unpack->GTW_epasControlType = x;
	/* GTW_epasEmergencyOn: start-bit 7, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 63) & 0x1;
	unpack->GTW_epasEmergencyOn = x;
	/* GTW_epasLDWEnabled: start-bit 12, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 52) & 0x1;
	unpack->GTW_epasLDWEnabled = x;
	return 0;
}

bool decode_can_0x101_GTW_epasControlChecksum(can_0x101_GTW_epasControl_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->GTW_epasControlChecksum);
	*out = rval;
	return true;
}

bool encode_can_0x101_GTW_epasControlChecksum(can_0x101_GTW_epasControl_t *record, uint8_t in)
{
	record->GTW_epasControlChecksum = in;
	return true;
}

bool decode_can_0x101_GTW_epasPowerMode(can_0x101_GTW_epasControl_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->GTW_epasPowerMode);
	if ((rval >= 4) && (rval <= 14)) {
		*out = rval;
		return true;
	} else {
		*out = (uint8_t)0;
		return false;
	}
}

bool encode_can_0x101_GTW_epasPowerMode(can_0x101_GTW_epasControl_t *record, uint8_t in)
{
	record->GTW_epasPowerMode = 0;
	if (in < 4)
		return false;
	if (in > 14)
		return false;
	record->GTW_epasPowerMode = in;
	return true;
}

bool decode_can_0x101_GTW_epasControlCounter(can_0x101_GTW_epasControl_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->GTW_epasControlCounter);
	*out = rval;
	return true;
}

bool encode_can_0x101_GTW_epasControlCounter(can_0x101_GTW_epasControl_t *record, uint8_t in)
{
	record->GTW_epasControlCounter = in;
	return true;
}

bool decode_can_0x101_GTW_epasTuneRequest(can_0x101_GTW_epasControl_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->GTW_epasTuneRequest);
	*out = rval;
	return true;
}

bool encode_can_0x101_GTW_epasTuneRequest(can_0x101_GTW_epasControl_t *record, uint8_t in)
{
	record->GTW_epasTuneRequest = in;
	return true;
}

bool decode_can_0x101_GTW_epasControlType(can_0x101_GTW_epasControl_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->GTW_epasControlType);
	*out = rval;
	return true;
}

bool encode_can_0x101_GTW_epasControlType(can_0x101_GTW_epasControl_t *record, uint8_t in)
{
	record->GTW_epasControlType = in;
	return true;
}

bool decode_can_0x101_GTW_epasEmergencyOn(can_0x101_GTW_epasControl_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->GTW_epasEmergencyOn);
	*out = rval;
	return true;
}

bool encode_can_0x101_GTW_epasEmergencyOn(can_0x101_GTW_epasControl_t *record, uint8_t in)
{
	record->GTW_epasEmergencyOn = in;
	return true;
}

bool decode_can_0x101_GTW_epasLDWEnabled(can_0x101_GTW_epasControl_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->GTW_epasLDWEnabled);
	*out = rval;
	return true;
}

bool encode_can_0x101_GTW_epasLDWEnabled(can_0x101_GTW_epasControl_t *record, uint8_t in)
{
	record->GTW_epasLDWEnabled = in;
	return true;
}

int print_can_0x101_GTW_epasControl(can_0x101_GTW_epasControl_t *print, FILE *data)
{
	int r = 0;
	r = phelper(r, fprintf(data, "GTW_epasControlChecksum = (wire: %.0f)\n", (double)(print->GTW_epasControlChecksum)));
	r = phelper(r, fprintf(data, "GTW_epasPowerMode = (wire: %.0f)\n", (double)(print->GTW_epasPowerMode)));
	r = phelper(r, fprintf(data, "GTW_epasControlCounter = (wire: %.0f)\n", (double)(print->GTW_epasControlCounter)));
	r = phelper(r, fprintf(data, "GTW_epasTuneRequest = (wire: %.0f)\n", (double)(print->GTW_epasTuneRequest)));
	r = phelper(r, fprintf(data, "GTW_epasControlType = (wire: %.0f)\n", (double)(print->GTW_epasControlType)));
	r = phelper(r, fprintf(data, "GTW_epasEmergencyOn = (wire: %.0f)\n", (double)(print->GTW_epasEmergencyOn)));
	r = phelper(r, fprintf(data, "GTW_epasLDWEnabled = (wire: %.0f)\n", (double)(print->GTW_epasLDWEnabled)));
	return r;
}

int pack_can_0x108_DI_torque1(can_0x108_DI_torque1_t *pack, uint64_t *data)
{
	register uint64_t x;
	register uint64_t i = 0;
	/* DI_motorRPM: start-bit 32, length 16, endianess intel, scaling 1, offset 0 */
	x = ((uint16_t)(pack->DI_motorRPM)) & 0xffff;
	x <<= 32; 
	i |= x;
	/* DI_torqueDriver: start-bit 0, length 13, endianess intel, scaling 0.25, offset 0 */
	x = ((uint16_t)(pack->DI_torqueDriver)) & 0x1fff;
	i |= x;
	/* DI_torqueMotor: start-bit 16, length 13, endianess intel, scaling 0.25, offset 0 */
	x = ((uint16_t)(pack->DI_torqueMotor)) & 0x1fff;
	x <<= 16; 
	i |= x;
	/* DI_pedalPos: start-bit 48, length 8, endianess intel, scaling 0.4, offset 0 */
	x = ((uint8_t)(pack->DI_pedalPos)) & 0xff;
	x <<= 48; 
	i |= x;
	/* DI_torque1Checksum: start-bit 56, length 8, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_torque1Checksum)) & 0xff;
	x <<= 56; 
	i |= x;
	/* DI_torque1Counter: start-bit 13, length 3, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_torque1Counter)) & 0x7;
	x <<= 13; 
	i |= x;
	/* DI_soptState: start-bit 29, length 3, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_soptState)) & 0x7;
	x <<= 29; 
	i |= x;
	*data = (i);
	return 0;
}

int unpack_can_0x108_DI_torque1(can_0x108_DI_torque1_t *unpack, uint64_t data, uint8_t dlc)
{
	register uint64_t x;
	register uint64_t i = (data);
	if (dlc < 8)
		return -1;
	/* DI_motorRPM: start-bit 32, length 16, endianess intel, scaling 1, offset 0 */
	x = (i >> 32) & 0xffff;
	unpack->DI_motorRPM = x;
	/* DI_torqueDriver: start-bit 0, length 13, endianess intel, scaling 0.25, offset 0 */
	x = i & 0x1fff;
	x = x & 0x1000 ? x | 0xe000 : x; 
	unpack->DI_torqueDriver = x;
	/* DI_torqueMotor: start-bit 16, length 13, endianess intel, scaling 0.25, offset 0 */
	x = (i >> 16) & 0x1fff;
	x = x & 0x1000 ? x | 0xe000 : x; 
	unpack->DI_torqueMotor = x;
	/* DI_pedalPos: start-bit 48, length 8, endianess intel, scaling 0.4, offset 0 */
	x = (i >> 48) & 0xff;
	unpack->DI_pedalPos = x;
	/* DI_torque1Checksum: start-bit 56, length 8, endianess intel, scaling 1, offset 0 */
	x = (i >> 56) & 0xff;
	unpack->DI_torque1Checksum = x;
	/* DI_torque1Counter: start-bit 13, length 3, endianess intel, scaling 1, offset 0 */
	x = (i >> 13) & 0x7;
	unpack->DI_torque1Counter = x;
	/* DI_soptState: start-bit 29, length 3, endianess intel, scaling 1, offset 0 */
	x = (i >> 29) & 0x7;
	unpack->DI_soptState = x;
	return 0;
}

bool decode_can_0x108_DI_motorRPM(can_0x108_DI_torque1_t *record, int16_t *out)
{
	int16_t rval = (int16_t)(record->DI_motorRPM);
	if ((rval >= -17000) && (rval <= 17000)) {
		*out = rval;
		return true;
	} else {
		*out = (int16_t)0;
		return false;
	}
}

bool encode_can_0x108_DI_motorRPM(can_0x108_DI_torque1_t *record, int16_t in)
{
	record->DI_motorRPM = 0;
	if (in < -17000)
		return false;
	if (in > 17000)
		return false;
	record->DI_motorRPM = in;
	return true;
}

bool decode_can_0x108_DI_torqueDriver(can_0x108_DI_torque1_t *record, double *out)
{
	double rval = (double)(record->DI_torqueDriver);
	rval *= 0.25;
	if ((rval >= -750) && (rval <= 750)) {
		*out = rval;
		return true;
	} else {
		*out = (double)0;
		return false;
	}
}

bool encode_can_0x108_DI_torqueDriver(can_0x108_DI_torque1_t *record, double in)
{
	record->DI_torqueDriver = 0;
	if (in < -750)
		return false;
	if (in > 750)
		return false;
	in *= 4;
	record->DI_torqueDriver = in;
	return true;
}

bool decode_can_0x108_DI_torqueMotor(can_0x108_DI_torque1_t *record, double *out)
{
	double rval = (double)(record->DI_torqueMotor);
	rval *= 0.25;
	if ((rval >= -750) && (rval <= 750)) {
		*out = rval;
		return true;
	} else {
		*out = (double)0;
		return false;
	}
}

bool encode_can_0x108_DI_torqueMotor(can_0x108_DI_torque1_t *record, double in)
{
	record->DI_torqueMotor = 0;
	if (in < -750)
		return false;
	if (in > 750)
		return false;
	in *= 4;
	record->DI_torqueMotor = in;
	return true;
}

bool decode_can_0x108_DI_pedalPos(can_0x108_DI_torque1_t *record, double *out)
{
	double rval = (double)(record->DI_pedalPos);
	rval *= 0.4;
	if (rval <= 100) {
		*out = rval;
		return true;
	} else {
		*out = (double)0;
		return false;
	}
}

bool encode_can_0x108_DI_pedalPos(can_0x108_DI_torque1_t *record, double in)
{
	record->DI_pedalPos = 0;
	if (in > 100)
		return false;
	in *= 2.5;
	record->DI_pedalPos = in;
	return true;
}

bool decode_can_0x108_DI_torque1Checksum(can_0x108_DI_torque1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_torque1Checksum);
	*out = rval;
	return true;
}

bool encode_can_0x108_DI_torque1Checksum(can_0x108_DI_torque1_t *record, uint8_t in)
{
	record->DI_torque1Checksum = in;
	return true;
}

bool decode_can_0x108_DI_torque1Counter(can_0x108_DI_torque1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_torque1Counter);
	*out = rval;
	return true;
}

bool encode_can_0x108_DI_torque1Counter(can_0x108_DI_torque1_t *record, uint8_t in)
{
	record->DI_torque1Counter = in;
	return true;
}

bool decode_can_0x108_DI_soptState(can_0x108_DI_torque1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_soptState);
	*out = rval;
	return true;
}

bool encode_can_0x108_DI_soptState(can_0x108_DI_torque1_t *record, uint8_t in)
{
	record->DI_soptState = in;
	return true;
}

int print_can_0x108_DI_torque1(can_0x108_DI_torque1_t *print, FILE *data)
{
	int r = 0;
	r = phelper(r, fprintf(data, "DI_motorRPM = (wire: %.0f)\n", (double)(print->DI_motorRPM)));
	r = phelper(r, fprintf(data, "DI_torqueDriver = (wire: %.0f)\n", (double)(print->DI_torqueDriver)));
	r = phelper(r, fprintf(data, "DI_torqueMotor = (wire: %.0f)\n", (double)(print->DI_torqueMotor)));
	r = phelper(r, fprintf(data, "DI_pedalPos = (wire: %.0f)\n", (double)(print->DI_pedalPos)));
	r = phelper(r, fprintf(data, "DI_torque1Checksum = (wire: %.0f)\n", (double)(print->DI_torque1Checksum)));
	r = phelper(r, fprintf(data, "DI_torque1Counter = (wire: %.0f)\n", (double)(print->DI_torque1Counter)));
	r = phelper(r, fprintf(data, "DI_soptState = (wire: %.0f)\n", (double)(print->DI_soptState)));
	return r;
}

int pack_can_0x118_DI_torque2(can_0x118_DI_torque2_t *pack, uint64_t *data)
{
	register uint64_t x;
	register uint64_t i = 0;
	/* DI_torqueEstimate: start-bit 0, length 12, endianess intel, scaling 0.5, offset 0 */
	x = ((uint16_t)(pack->DI_torqueEstimate)) & 0xfff;
	i |= x;
	/* DI_vehicleSpeed: start-bit 16, length 12, endianess intel, scaling 0.05, offset -25 */
	x = ((uint16_t)(pack->DI_vehicleSpeed)) & 0xfff;
	x <<= 16; 
	i |= x;
	/* DI_torque2Checksum: start-bit 40, length 8, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_torque2Checksum)) & 0xff;
	x <<= 40; 
	i |= x;
	/* DI_torque2Counter: start-bit 32, length 4, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_torque2Counter)) & 0xf;
	x <<= 32; 
	i |= x;
	/* DI_gear: start-bit 12, length 3, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_gear)) & 0x7;
	x <<= 12; 
	i |= x;
	/* DI_gearRequest: start-bit 28, length 3, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_gearRequest)) & 0x7;
	x <<= 28; 
	i |= x;
	/* DI_brakePedalState: start-bit 36, length 2, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_brakePedalState)) & 0x3;
	x <<= 36; 
	i |= x;
	/* DI_brakePedal: start-bit 15, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_brakePedal)) & 0x1;
	x <<= 15; 
	i |= x;
	/* DI_torqueInterfaceFailure: start-bit 31, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_torqueInterfaceFailure)) & 0x1;
	x <<= 31; 
	i |= x;
	/* DI_epbParkRequest: start-bit 38, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_epbParkRequest)) & 0x1;
	x <<= 38; 
	i |= x;
	/* DI_epbInterfaceReady: start-bit 39, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_epbInterfaceReady)) & 0x1;
	x <<= 39; 
	i |= x;
	*data = (i);
	return 0;
}

int unpack_can_0x118_DI_torque2(can_0x118_DI_torque2_t *unpack, uint64_t data, uint8_t dlc)
{
	register uint64_t x;
	register uint64_t i = (data);
	if (dlc < 6)
		return -1;
	/* DI_torqueEstimate: start-bit 0, length 12, endianess intel, scaling 0.5, offset 0 */
	x = i & 0xfff;
	x = x & 0x800 ? x | 0xf000 : x; 
	unpack->DI_torqueEstimate = x;
	/* DI_vehicleSpeed: start-bit 16, length 12, endianess intel, scaling 0.05, offset -25 */
	x = (i >> 16) & 0xfff;
	unpack->DI_vehicleSpeed = x;
	/* DI_torque2Checksum: start-bit 40, length 8, endianess intel, scaling 1, offset 0 */
	x = (i >> 40) & 0xff;
	unpack->DI_torque2Checksum = x;
	/* DI_torque2Counter: start-bit 32, length 4, endianess intel, scaling 1, offset 0 */
	x = (i >> 32) & 0xf;
	unpack->DI_torque2Counter = x;
	/* DI_gear: start-bit 12, length 3, endianess intel, scaling 1, offset 0 */
	x = (i >> 12) & 0x7;
	unpack->DI_gear = x;
	/* DI_gearRequest: start-bit 28, length 3, endianess intel, scaling 1, offset 0 */
	x = (i >> 28) & 0x7;
	unpack->DI_gearRequest = x;
	/* DI_brakePedalState: start-bit 36, length 2, endianess intel, scaling 1, offset 0 */
	x = (i >> 36) & 0x3;
	unpack->DI_brakePedalState = x;
	/* DI_brakePedal: start-bit 15, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 15) & 0x1;
	unpack->DI_brakePedal = x;
	/* DI_torqueInterfaceFailure: start-bit 31, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 31) & 0x1;
	unpack->DI_torqueInterfaceFailure = x;
	/* DI_epbParkRequest: start-bit 38, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 38) & 0x1;
	unpack->DI_epbParkRequest = x;
	/* DI_epbInterfaceReady: start-bit 39, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 39) & 0x1;
	unpack->DI_epbInterfaceReady = x;
	return 0;
}

bool decode_can_0x118_DI_torqueEstimate(can_0x118_DI_torque2_t *record, double *out)
{
	double rval = (double)(record->DI_torqueEstimate);
	rval *= 0.5;
	if ((rval >= -750) && (rval <= 750)) {
		*out = rval;
		return true;
	} else {
		*out = (double)0;
		return false;
	}
}

bool encode_can_0x118_DI_torqueEstimate(can_0x118_DI_torque2_t *record, double in)
{
	record->DI_torqueEstimate = 0;
	if (in < -750)
		return false;
	if (in > 750)
		return false;
	in *= 2;
	record->DI_torqueEstimate = in;
	return true;
}

bool decode_can_0x118_DI_vehicleSpeed(can_0x118_DI_torque2_t *record, double *out)
{
	double rval = (double)(record->DI_vehicleSpeed);
	rval *= 0.05;
	rval += -25;
	if (rval <= 179.75) {
		*out = rval;
		return true;
	} else {
		*out = (double)0;
		return false;
	}
}

bool encode_can_0x118_DI_vehicleSpeed(can_0x118_DI_torque2_t *record, double in)
{
	record->DI_vehicleSpeed = 0;
	if (in > 179.75)
		return false;
	in += 25;
	in *= 20;
	record->DI_vehicleSpeed = in;
	return true;
}

bool decode_can_0x118_DI_torque2Checksum(can_0x118_DI_torque2_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_torque2Checksum);
	*out = rval;
	return true;
}

bool encode_can_0x118_DI_torque2Checksum(can_0x118_DI_torque2_t *record, uint8_t in)
{
	record->DI_torque2Checksum = in;
	return true;
}

bool decode_can_0x118_DI_torque2Counter(can_0x118_DI_torque2_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_torque2Counter);
	*out = rval;
	return true;
}

bool encode_can_0x118_DI_torque2Counter(can_0x118_DI_torque2_t *record, uint8_t in)
{
	record->DI_torque2Counter = in;
	return true;
}

bool decode_can_0x118_DI_gear(can_0x118_DI_torque2_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_gear);
	*out = rval;
	return true;
}

bool encode_can_0x118_DI_gear(can_0x118_DI_torque2_t *record, uint8_t in)
{
	record->DI_gear = in;
	return true;
}

bool decode_can_0x118_DI_gearRequest(can_0x118_DI_torque2_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_gearRequest);
	*out = rval;
	return true;
}

bool encode_can_0x118_DI_gearRequest(can_0x118_DI_torque2_t *record, uint8_t in)
{
	record->DI_gearRequest = in;
	return true;
}

bool decode_can_0x118_DI_brakePedalState(can_0x118_DI_torque2_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_brakePedalState);
	*out = rval;
	return true;
}

bool encode_can_0x118_DI_brakePedalState(can_0x118_DI_torque2_t *record, uint8_t in)
{
	record->DI_brakePedalState = in;
	return true;
}

bool decode_can_0x118_DI_brakePedal(can_0x118_DI_torque2_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_brakePedal);
	*out = rval;
	return true;
}

bool encode_can_0x118_DI_brakePedal(can_0x118_DI_torque2_t *record, uint8_t in)
{
	record->DI_brakePedal = in;
	return true;
}

bool decode_can_0x118_DI_torqueInterfaceFailure(can_0x118_DI_torque2_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_torqueInterfaceFailure);
	*out = rval;
	return true;
}

bool encode_can_0x118_DI_torqueInterfaceFailure(can_0x118_DI_torque2_t *record, uint8_t in)
{
	record->DI_torqueInterfaceFailure = in;
	return true;
}

bool decode_can_0x118_DI_epbParkRequest(can_0x118_DI_torque2_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_epbParkRequest);
	*out = rval;
	return true;
}

bool encode_can_0x118_DI_epbParkRequest(can_0x118_DI_torque2_t *record, uint8_t in)
{
	record->DI_epbParkRequest = in;
	return true;
}

bool decode_can_0x118_DI_epbInterfaceReady(can_0x118_DI_torque2_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_epbInterfaceReady);
	*out = rval;
	return true;
}

bool encode_can_0x118_DI_epbInterfaceReady(can_0x118_DI_torque2_t *record, uint8_t in)
{
	record->DI_epbInterfaceReady = in;
	return true;
}

int print_can_0x118_DI_torque2(can_0x118_DI_torque2_t *print, FILE *data)
{
	int r = 0;
	r = phelper(r, fprintf(data, "DI_torqueEstimate = (wire: %.0f)\n", (double)(print->DI_torqueEstimate)));
	r = phelper(r, fprintf(data, "DI_vehicleSpeed = (wire: %.0f)\n", (double)(print->DI_vehicleSpeed)));
	r = phelper(r, fprintf(data, "DI_torque2Checksum = (wire: %.0f)\n", (double)(print->DI_torque2Checksum)));
	r = phelper(r, fprintf(data, "DI_torque2Counter = (wire: %.0f)\n", (double)(print->DI_torque2Counter)));
	r = phelper(r, fprintf(data, "DI_gear = (wire: %.0f)\n", (double)(print->DI_gear)));
	r = phelper(r, fprintf(data, "DI_gearRequest = (wire: %.0f)\n", (double)(print->DI_gearRequest)));
	r = phelper(r, fprintf(data, "DI_brakePedalState = (wire: %.0f)\n", (double)(print->DI_brakePedalState)));
	r = phelper(r, fprintf(data, "DI_brakePedal = (wire: %.0f)\n", (double)(print->DI_brakePedal)));
	r = phelper(r, fprintf(data, "DI_torqueInterfaceFailure = (wire: %.0f)\n", (double)(print->DI_torqueInterfaceFailure)));
	r = phelper(r, fprintf(data, "DI_epbParkRequest = (wire: %.0f)\n", (double)(print->DI_epbParkRequest)));
	r = phelper(r, fprintf(data, "DI_epbInterfaceReady = (wire: %.0f)\n", (double)(print->DI_epbInterfaceReady)));
	return r;
}

int pack_can_0x135_ESP_135h(can_0x135_ESP_135h_t *pack, uint64_t *data)
{
	register uint64_t x;
	register uint64_t m = 0;
	/* ESP_135hChecksum: start-bit 23, length 8, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_135hChecksum)) & 0xff;
	x <<= 40; 
	m |= x;
	/* ESP_135hCounter: start-bit 11, length 4, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_135hCounter)) & 0xf;
	x <<= 48; 
	m |= x;
	/* ESP_stabilityControlSts: start-bit 14, length 3, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_stabilityControlSts)) & 0x7;
	x <<= 52; 
	m |= x;
	/* ESP_hillStartAssistActive: start-bit 1, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_hillStartAssistActive)) & 0x3;
	x <<= 56; 
	m |= x;
	/* ESP_absBrakeEvent: start-bit 2, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_absBrakeEvent)) & 0x1;
	x <<= 58; 
	m |= x;
	/* ESP_brakeLamp: start-bit 3, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_brakeLamp)) & 0x1;
	x <<= 59; 
	m |= x;
	/* ESP_brakeDiscWipingActive: start-bit 4, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_brakeDiscWipingActive)) & 0x1;
	x <<= 60; 
	m |= x;
	/* ESP_tcLampFlash: start-bit 5, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_tcLampFlash)) & 0x1;
	x <<= 61; 
	m |= x;
	/* ESP_espFaultLamp: start-bit 6, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_espFaultLamp)) & 0x1;
	x <<= 62; 
	m |= x;
	/* ESP_espLampFlash: start-bit 7, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_espLampFlash)) & 0x1;
	x <<= 63; 
	m |= x;
	/* ESP_tcOffLamp: start-bit 15, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_tcOffLamp)) & 0x1;
	x <<= 55; 
	m |= x;
	/* ESP_messagePumpService: start-bit 24, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_messagePumpService)) & 0x1;
	x <<= 32; 
	m |= x;
	/* ESP_messagePumpFailure: start-bit 25, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_messagePumpFailure)) & 0x1;
	x <<= 33; 
	m |= x;
	/* ESP_messageEBDFailure: start-bit 26, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_messageEBDFailure)) & 0x1;
	x <<= 34; 
	m |= x;
	/* ESP_absFaultLamp: start-bit 27, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_absFaultLamp)) & 0x1;
	x <<= 35; 
	m |= x;
	/* ESP_tcDisabledByFault: start-bit 28, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_tcDisabledByFault)) & 0x1;
	x <<= 36; 
	m |= x;
	/* ESP_messageDynoModeActive: start-bit 29, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_messageDynoModeActive)) & 0x1;
	x <<= 37; 
	m |= x;
	/* ESP_hydraulicBoostEnabled: start-bit 30, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_hydraulicBoostEnabled)) & 0x1;
	x <<= 38; 
	m |= x;
	/* ESP_espOffLamp: start-bit 31, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_espOffLamp)) & 0x1;
	x <<= 39; 
	m |= x;
	*data = reverse_byte_order(m);
	return 0;
}

int unpack_can_0x135_ESP_135h(can_0x135_ESP_135h_t *unpack, uint64_t data, uint8_t dlc)
{
	register uint64_t x;
	register uint64_t m = reverse_byte_order(data);
	if (dlc < 5)
		return -1;
	/* ESP_135hChecksum: start-bit 23, length 8, endianess motorola, scaling 1, offset 0 */
	x = (m >> 40) & 0xff;
	unpack->ESP_135hChecksum = x;
	/* ESP_135hCounter: start-bit 11, length 4, endianess motorola, scaling 1, offset 0 */
	x = (m >> 48) & 0xf;
	unpack->ESP_135hCounter = x;
	/* ESP_stabilityControlSts: start-bit 14, length 3, endianess motorola, scaling 1, offset 0 */
	x = (m >> 52) & 0x7;
	unpack->ESP_stabilityControlSts = x;
	/* ESP_hillStartAssistActive: start-bit 1, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 56) & 0x3;
	unpack->ESP_hillStartAssistActive = x;
	/* ESP_absBrakeEvent: start-bit 2, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 58) & 0x1;
	unpack->ESP_absBrakeEvent = x;
	/* ESP_brakeLamp: start-bit 3, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 59) & 0x1;
	unpack->ESP_brakeLamp = x;
	/* ESP_brakeDiscWipingActive: start-bit 4, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 60) & 0x1;
	unpack->ESP_brakeDiscWipingActive = x;
	/* ESP_tcLampFlash: start-bit 5, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 61) & 0x1;
	unpack->ESP_tcLampFlash = x;
	/* ESP_espFaultLamp: start-bit 6, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 62) & 0x1;
	unpack->ESP_espFaultLamp = x;
	/* ESP_espLampFlash: start-bit 7, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 63) & 0x1;
	unpack->ESP_espLampFlash = x;
	/* ESP_tcOffLamp: start-bit 15, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 55) & 0x1;
	unpack->ESP_tcOffLamp = x;
	/* ESP_messagePumpService: start-bit 24, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 32) & 0x1;
	unpack->ESP_messagePumpService = x;
	/* ESP_messagePumpFailure: start-bit 25, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 33) & 0x1;
	unpack->ESP_messagePumpFailure = x;
	/* ESP_messageEBDFailure: start-bit 26, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 34) & 0x1;
	unpack->ESP_messageEBDFailure = x;
	/* ESP_absFaultLamp: start-bit 27, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 35) & 0x1;
	unpack->ESP_absFaultLamp = x;
	/* ESP_tcDisabledByFault: start-bit 28, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 36) & 0x1;
	unpack->ESP_tcDisabledByFault = x;
	/* ESP_messageDynoModeActive: start-bit 29, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 37) & 0x1;
	unpack->ESP_messageDynoModeActive = x;
	/* ESP_hydraulicBoostEnabled: start-bit 30, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 38) & 0x1;
	unpack->ESP_hydraulicBoostEnabled = x;
	/* ESP_espOffLamp: start-bit 31, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 39) & 0x1;
	unpack->ESP_espOffLamp = x;
	return 0;
}

bool decode_can_0x135_ESP_135hChecksum(can_0x135_ESP_135h_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_135hChecksum);
	*out = rval;
	return true;
}

bool encode_can_0x135_ESP_135hChecksum(can_0x135_ESP_135h_t *record, uint8_t in)
{
	record->ESP_135hChecksum = in;
	return true;
}

bool decode_can_0x135_ESP_135hCounter(can_0x135_ESP_135h_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_135hCounter);
	*out = rval;
	return true;
}

bool encode_can_0x135_ESP_135hCounter(can_0x135_ESP_135h_t *record, uint8_t in)
{
	record->ESP_135hCounter = in;
	return true;
}

bool decode_can_0x135_ESP_stabilityControlSts(can_0x135_ESP_135h_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_stabilityControlSts);
	if (rval >= 6) {
		*out = rval;
		return true;
	} else {
		*out = (uint8_t)0;
		return false;
	}
}

bool encode_can_0x135_ESP_stabilityControlSts(can_0x135_ESP_135h_t *record, uint8_t in)
{
	record->ESP_stabilityControlSts = 0;
	if (in < 6)
		return false;
	record->ESP_stabilityControlSts = in;
	return true;
}

bool decode_can_0x135_ESP_hillStartAssistActive(can_0x135_ESP_135h_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_hillStartAssistActive);
	*out = rval;
	return true;
}

bool encode_can_0x135_ESP_hillStartAssistActive(can_0x135_ESP_135h_t *record, uint8_t in)
{
	record->ESP_hillStartAssistActive = in;
	return true;
}

bool decode_can_0x135_ESP_absBrakeEvent(can_0x135_ESP_135h_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_absBrakeEvent);
	*out = rval;
	return true;
}

bool encode_can_0x135_ESP_absBrakeEvent(can_0x135_ESP_135h_t *record, uint8_t in)
{
	record->ESP_absBrakeEvent = in;
	return true;
}

bool decode_can_0x135_ESP_brakeLamp(can_0x135_ESP_135h_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_brakeLamp);
	*out = rval;
	return true;
}

bool encode_can_0x135_ESP_brakeLamp(can_0x135_ESP_135h_t *record, uint8_t in)
{
	record->ESP_brakeLamp = in;
	return true;
}

bool decode_can_0x135_ESP_brakeDiscWipingActive(can_0x135_ESP_135h_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_brakeDiscWipingActive);
	*out = rval;
	return true;
}

bool encode_can_0x135_ESP_brakeDiscWipingActive(can_0x135_ESP_135h_t *record, uint8_t in)
{
	record->ESP_brakeDiscWipingActive = in;
	return true;
}

bool decode_can_0x135_ESP_tcLampFlash(can_0x135_ESP_135h_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_tcLampFlash);
	*out = rval;
	return true;
}

bool encode_can_0x135_ESP_tcLampFlash(can_0x135_ESP_135h_t *record, uint8_t in)
{
	record->ESP_tcLampFlash = in;
	return true;
}

bool decode_can_0x135_ESP_espFaultLamp(can_0x135_ESP_135h_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_espFaultLamp);
	*out = rval;
	return true;
}

bool encode_can_0x135_ESP_espFaultLamp(can_0x135_ESP_135h_t *record, uint8_t in)
{
	record->ESP_espFaultLamp = in;
	return true;
}

bool decode_can_0x135_ESP_espLampFlash(can_0x135_ESP_135h_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_espLampFlash);
	*out = rval;
	return true;
}

bool encode_can_0x135_ESP_espLampFlash(can_0x135_ESP_135h_t *record, uint8_t in)
{
	record->ESP_espLampFlash = in;
	return true;
}

bool decode_can_0x135_ESP_tcOffLamp(can_0x135_ESP_135h_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_tcOffLamp);
	*out = rval;
	return true;
}

bool encode_can_0x135_ESP_tcOffLamp(can_0x135_ESP_135h_t *record, uint8_t in)
{
	record->ESP_tcOffLamp = in;
	return true;
}

bool decode_can_0x135_ESP_messagePumpService(can_0x135_ESP_135h_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_messagePumpService);
	*out = rval;
	return true;
}

bool encode_can_0x135_ESP_messagePumpService(can_0x135_ESP_135h_t *record, uint8_t in)
{
	record->ESP_messagePumpService = in;
	return true;
}

bool decode_can_0x135_ESP_messagePumpFailure(can_0x135_ESP_135h_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_messagePumpFailure);
	*out = rval;
	return true;
}

bool encode_can_0x135_ESP_messagePumpFailure(can_0x135_ESP_135h_t *record, uint8_t in)
{
	record->ESP_messagePumpFailure = in;
	return true;
}

bool decode_can_0x135_ESP_messageEBDFailure(can_0x135_ESP_135h_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_messageEBDFailure);
	*out = rval;
	return true;
}

bool encode_can_0x135_ESP_messageEBDFailure(can_0x135_ESP_135h_t *record, uint8_t in)
{
	record->ESP_messageEBDFailure = in;
	return true;
}

bool decode_can_0x135_ESP_absFaultLamp(can_0x135_ESP_135h_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_absFaultLamp);
	*out = rval;
	return true;
}

bool encode_can_0x135_ESP_absFaultLamp(can_0x135_ESP_135h_t *record, uint8_t in)
{
	record->ESP_absFaultLamp = in;
	return true;
}

bool decode_can_0x135_ESP_tcDisabledByFault(can_0x135_ESP_135h_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_tcDisabledByFault);
	*out = rval;
	return true;
}

bool encode_can_0x135_ESP_tcDisabledByFault(can_0x135_ESP_135h_t *record, uint8_t in)
{
	record->ESP_tcDisabledByFault = in;
	return true;
}

bool decode_can_0x135_ESP_messageDynoModeActive(can_0x135_ESP_135h_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_messageDynoModeActive);
	*out = rval;
	return true;
}

bool encode_can_0x135_ESP_messageDynoModeActive(can_0x135_ESP_135h_t *record, uint8_t in)
{
	record->ESP_messageDynoModeActive = in;
	return true;
}

bool decode_can_0x135_ESP_hydraulicBoostEnabled(can_0x135_ESP_135h_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_hydraulicBoostEnabled);
	*out = rval;
	return true;
}

bool encode_can_0x135_ESP_hydraulicBoostEnabled(can_0x135_ESP_135h_t *record, uint8_t in)
{
	record->ESP_hydraulicBoostEnabled = in;
	return true;
}

bool decode_can_0x135_ESP_espOffLamp(can_0x135_ESP_135h_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_espOffLamp);
	*out = rval;
	return true;
}

bool encode_can_0x135_ESP_espOffLamp(can_0x135_ESP_135h_t *record, uint8_t in)
{
	record->ESP_espOffLamp = in;
	return true;
}

int print_can_0x135_ESP_135h(can_0x135_ESP_135h_t *print, FILE *data)
{
	int r = 0;
	r = phelper(r, fprintf(data, "ESP_135hChecksum = (wire: %.0f)\n", (double)(print->ESP_135hChecksum)));
	r = phelper(r, fprintf(data, "ESP_135hCounter = (wire: %.0f)\n", (double)(print->ESP_135hCounter)));
	r = phelper(r, fprintf(data, "ESP_stabilityControlSts = (wire: %.0f)\n", (double)(print->ESP_stabilityControlSts)));
	r = phelper(r, fprintf(data, "ESP_hillStartAssistActive = (wire: %.0f)\n", (double)(print->ESP_hillStartAssistActive)));
	r = phelper(r, fprintf(data, "ESP_absBrakeEvent = (wire: %.0f)\n", (double)(print->ESP_absBrakeEvent)));
	r = phelper(r, fprintf(data, "ESP_brakeLamp = (wire: %.0f)\n", (double)(print->ESP_brakeLamp)));
	r = phelper(r, fprintf(data, "ESP_brakeDiscWipingActive = (wire: %.0f)\n", (double)(print->ESP_brakeDiscWipingActive)));
	r = phelper(r, fprintf(data, "ESP_tcLampFlash = (wire: %.0f)\n", (double)(print->ESP_tcLampFlash)));
	r = phelper(r, fprintf(data, "ESP_espFaultLamp = (wire: %.0f)\n", (double)(print->ESP_espFaultLamp)));
	r = phelper(r, fprintf(data, "ESP_espLampFlash = (wire: %.0f)\n", (double)(print->ESP_espLampFlash)));
	r = phelper(r, fprintf(data, "ESP_tcOffLamp = (wire: %.0f)\n", (double)(print->ESP_tcOffLamp)));
	r = phelper(r, fprintf(data, "ESP_messagePumpService = (wire: %.0f)\n", (double)(print->ESP_messagePumpService)));
	r = phelper(r, fprintf(data, "ESP_messagePumpFailure = (wire: %.0f)\n", (double)(print->ESP_messagePumpFailure)));
	r = phelper(r, fprintf(data, "ESP_messageEBDFailure = (wire: %.0f)\n", (double)(print->ESP_messageEBDFailure)));
	r = phelper(r, fprintf(data, "ESP_absFaultLamp = (wire: %.0f)\n", (double)(print->ESP_absFaultLamp)));
	r = phelper(r, fprintf(data, "ESP_tcDisabledByFault = (wire: %.0f)\n", (double)(print->ESP_tcDisabledByFault)));
	r = phelper(r, fprintf(data, "ESP_messageDynoModeActive = (wire: %.0f)\n", (double)(print->ESP_messageDynoModeActive)));
	r = phelper(r, fprintf(data, "ESP_hydraulicBoostEnabled = (wire: %.0f)\n", (double)(print->ESP_hydraulicBoostEnabled)));
	r = phelper(r, fprintf(data, "ESP_espOffLamp = (wire: %.0f)\n", (double)(print->ESP_espOffLamp)));
	return r;
}

int pack_can_0x155_ESP_B(can_0x155_ESP_B_t *pack, uint64_t *data)
{
	register uint64_t x;
	register uint64_t m = 0;
	/* ESP_vehicleSpeed: start-bit 47, length 16, endianess motorola, scaling 0.01, offset 0 */
	x = ((uint16_t)(pack->ESP_vehicleSpeed)) & 0xffff;
	x <<= 8; 
	m |= x;
	/* ESP_wheelPulseCountFrL: start-bit 7, length 8, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_wheelPulseCountFrL)) & 0xff;
	x <<= 56; 
	m |= x;
	/* ESP_wheelPulseCountFrR: start-bit 15, length 8, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_wheelPulseCountFrR)) & 0xff;
	x <<= 48; 
	m |= x;
	/* ESP_wheelPulseCountReL: start-bit 23, length 8, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_wheelPulseCountReL)) & 0xff;
	x <<= 40; 
	m |= x;
	/* ESP_wheelPulseCountReR: start-bit 31, length 8, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_wheelPulseCountReR)) & 0xff;
	x <<= 32; 
	m |= x;
	/* ESP_BChecksum: start-bit 39, length 8, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_BChecksum)) & 0xff;
	x <<= 24; 
	m |= x;
	/* ESP_BCounter: start-bit 62, length 4, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_BCounter)) & 0xf;
	x <<= 3; 
	m |= x;
	/* ESP_vehicleSpeedQF: start-bit 57, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ESP_vehicleSpeedQF)) & 0x3;
	m |= x;
	*data = reverse_byte_order(m);
	return 0;
}

int unpack_can_0x155_ESP_B(can_0x155_ESP_B_t *unpack, uint64_t data, uint8_t dlc)
{
	register uint64_t x;
	register uint64_t m = reverse_byte_order(data);
	if (dlc < 8)
		return -1;
	/* ESP_vehicleSpeed: start-bit 47, length 16, endianess motorola, scaling 0.01, offset 0 */
	x = (m >> 8) & 0xffff;
	unpack->ESP_vehicleSpeed = x;
	/* ESP_wheelPulseCountFrL: start-bit 7, length 8, endianess motorola, scaling 1, offset 0 */
	x = (m >> 56) & 0xff;
	unpack->ESP_wheelPulseCountFrL = x;
	/* ESP_wheelPulseCountFrR: start-bit 15, length 8, endianess motorola, scaling 1, offset 0 */
	x = (m >> 48) & 0xff;
	unpack->ESP_wheelPulseCountFrR = x;
	/* ESP_wheelPulseCountReL: start-bit 23, length 8, endianess motorola, scaling 1, offset 0 */
	x = (m >> 40) & 0xff;
	unpack->ESP_wheelPulseCountReL = x;
	/* ESP_wheelPulseCountReR: start-bit 31, length 8, endianess motorola, scaling 1, offset 0 */
	x = (m >> 32) & 0xff;
	unpack->ESP_wheelPulseCountReR = x;
	/* ESP_BChecksum: start-bit 39, length 8, endianess motorola, scaling 1, offset 0 */
	x = (m >> 24) & 0xff;
	unpack->ESP_BChecksum = x;
	/* ESP_BCounter: start-bit 62, length 4, endianess motorola, scaling 1, offset 0 */
	x = (m >> 3) & 0xf;
	unpack->ESP_BCounter = x;
	/* ESP_vehicleSpeedQF: start-bit 57, length 2, endianess motorola, scaling 1, offset 0 */
	x = m & 0x3;
	unpack->ESP_vehicleSpeedQF = x;
	return 0;
}

bool decode_can_0x155_ESP_vehicleSpeed(can_0x155_ESP_B_t *record, double *out)
{
	double rval = (double)(record->ESP_vehicleSpeed);
	rval *= 0.01;
	*out = rval;
	return true;
}

bool encode_can_0x155_ESP_vehicleSpeed(can_0x155_ESP_B_t *record, double in)
{
	in *= 100;
	record->ESP_vehicleSpeed = in;
	return true;
}

bool decode_can_0x155_ESP_wheelPulseCountFrL(can_0x155_ESP_B_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_wheelPulseCountFrL);
	if (rval <= 254) {
		*out = rval;
		return true;
	} else {
		*out = (uint8_t)0;
		return false;
	}
}

bool encode_can_0x155_ESP_wheelPulseCountFrL(can_0x155_ESP_B_t *record, uint8_t in)
{
	record->ESP_wheelPulseCountFrL = 0;
	if (in > 254)
		return false;
	record->ESP_wheelPulseCountFrL = in;
	return true;
}

bool decode_can_0x155_ESP_wheelPulseCountFrR(can_0x155_ESP_B_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_wheelPulseCountFrR);
	if (rval <= 254) {
		*out = rval;
		return true;
	} else {
		*out = (uint8_t)0;
		return false;
	}
}

bool encode_can_0x155_ESP_wheelPulseCountFrR(can_0x155_ESP_B_t *record, uint8_t in)
{
	record->ESP_wheelPulseCountFrR = 0;
	if (in > 254)
		return false;
	record->ESP_wheelPulseCountFrR = in;
	return true;
}

bool decode_can_0x155_ESP_wheelPulseCountReL(can_0x155_ESP_B_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_wheelPulseCountReL);
	if (rval <= 254) {
		*out = rval;
		return true;
	} else {
		*out = (uint8_t)0;
		return false;
	}
}

bool encode_can_0x155_ESP_wheelPulseCountReL(can_0x155_ESP_B_t *record, uint8_t in)
{
	record->ESP_wheelPulseCountReL = 0;
	if (in > 254)
		return false;
	record->ESP_wheelPulseCountReL = in;
	return true;
}

bool decode_can_0x155_ESP_wheelPulseCountReR(can_0x155_ESP_B_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_wheelPulseCountReR);
	if (rval <= 254) {
		*out = rval;
		return true;
	} else {
		*out = (uint8_t)0;
		return false;
	}
}

bool encode_can_0x155_ESP_wheelPulseCountReR(can_0x155_ESP_B_t *record, uint8_t in)
{
	record->ESP_wheelPulseCountReR = 0;
	if (in > 254)
		return false;
	record->ESP_wheelPulseCountReR = in;
	return true;
}

bool decode_can_0x155_ESP_BChecksum(can_0x155_ESP_B_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_BChecksum);
	*out = rval;
	return true;
}

bool encode_can_0x155_ESP_BChecksum(can_0x155_ESP_B_t *record, uint8_t in)
{
	record->ESP_BChecksum = in;
	return true;
}

bool decode_can_0x155_ESP_BCounter(can_0x155_ESP_B_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_BCounter);
	if (rval >= 1) {
		*out = rval;
		return true;
	} else {
		*out = (uint8_t)0;
		return false;
	}
}

bool encode_can_0x155_ESP_BCounter(can_0x155_ESP_B_t *record, uint8_t in)
{
	record->ESP_BCounter = 0;
	if (in < 1)
		return false;
	record->ESP_BCounter = in;
	return true;
}

bool decode_can_0x155_ESP_vehicleSpeedQF(can_0x155_ESP_B_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ESP_vehicleSpeedQF);
	if ((rval >= 1) && (rval <= 2)) {
		*out = rval;
		return true;
	} else {
		*out = (uint8_t)0;
		return false;
	}
}

bool encode_can_0x155_ESP_vehicleSpeedQF(can_0x155_ESP_B_t *record, uint8_t in)
{
	record->ESP_vehicleSpeedQF = 0;
	if (in < 1)
		return false;
	if (in > 2)
		return false;
	record->ESP_vehicleSpeedQF = in;
	return true;
}

int print_can_0x155_ESP_B(can_0x155_ESP_B_t *print, FILE *data)
{
	int r = 0;
	r = phelper(r, fprintf(data, "ESP_vehicleSpeed = (wire: %.0f)\n", (double)(print->ESP_vehicleSpeed)));
	r = phelper(r, fprintf(data, "ESP_wheelPulseCountFrL = (wire: %.0f)\n", (double)(print->ESP_wheelPulseCountFrL)));
	r = phelper(r, fprintf(data, "ESP_wheelPulseCountFrR = (wire: %.0f)\n", (double)(print->ESP_wheelPulseCountFrR)));
	r = phelper(r, fprintf(data, "ESP_wheelPulseCountReL = (wire: %.0f)\n", (double)(print->ESP_wheelPulseCountReL)));
	r = phelper(r, fprintf(data, "ESP_wheelPulseCountReR = (wire: %.0f)\n", (double)(print->ESP_wheelPulseCountReR)));
	r = phelper(r, fprintf(data, "ESP_BChecksum = (wire: %.0f)\n", (double)(print->ESP_BChecksum)));
	r = phelper(r, fprintf(data, "ESP_BCounter = (wire: %.0f)\n", (double)(print->ESP_BCounter)));
	r = phelper(r, fprintf(data, "ESP_vehicleSpeedQF = (wire: %.0f)\n", (double)(print->ESP_vehicleSpeedQF)));
	return r;
}

int pack_can_0x214_EPB_epasControl(can_0x214_EPB_epasControl_t *pack, uint64_t *data)
{
	register uint64_t x;
	register uint64_t m = 0;
	/* EPB_epasControlChecksum: start-bit 23, length 8, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->EPB_epasControlChecksum)) & 0xff;
	x <<= 40; 
	m |= x;
	/* EPB_epasControlCounter: start-bit 11, length 4, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->EPB_epasControlCounter)) & 0xf;
	x <<= 48; 
	m |= x;
	/* EPB_epasEACAllow: start-bit 2, length 3, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->EPB_epasEACAllow)) & 0x7;
	x <<= 56; 
	m |= x;
	*data = reverse_byte_order(m);
	return 0;
}

int unpack_can_0x214_EPB_epasControl(can_0x214_EPB_epasControl_t *unpack, uint64_t data, uint8_t dlc)
{
	register uint64_t x;
	register uint64_t m = reverse_byte_order(data);
	if (dlc < 3)
		return -1;
	/* EPB_epasControlChecksum: start-bit 23, length 8, endianess motorola, scaling 1, offset 0 */
	x = (m >> 40) & 0xff;
	unpack->EPB_epasControlChecksum = x;
	/* EPB_epasControlCounter: start-bit 11, length 4, endianess motorola, scaling 1, offset 0 */
	x = (m >> 48) & 0xf;
	unpack->EPB_epasControlCounter = x;
	/* EPB_epasEACAllow: start-bit 2, length 3, endianess motorola, scaling 1, offset 0 */
	x = (m >> 56) & 0x7;
	unpack->EPB_epasEACAllow = x;
	return 0;
}

bool decode_can_0x214_EPB_epasControlChecksum(can_0x214_EPB_epasControl_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->EPB_epasControlChecksum);
	*out = rval;
	return true;
}

bool encode_can_0x214_EPB_epasControlChecksum(can_0x214_EPB_epasControl_t *record, uint8_t in)
{
	record->EPB_epasControlChecksum = in;
	return true;
}

bool decode_can_0x214_EPB_epasControlCounter(can_0x214_EPB_epasControl_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->EPB_epasControlCounter);
	*out = rval;
	return true;
}

bool encode_can_0x214_EPB_epasControlCounter(can_0x214_EPB_epasControl_t *record, uint8_t in)
{
	record->EPB_epasControlCounter = in;
	return true;
}

bool decode_can_0x214_EPB_epasEACAllow(can_0x214_EPB_epasControl_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->EPB_epasEACAllow);
	if (rval >= 4) {
		*out = rval;
		return true;
	} else {
		*out = (uint8_t)0;
		return false;
	}
}

bool encode_can_0x214_EPB_epasEACAllow(can_0x214_EPB_epasControl_t *record, uint8_t in)
{
	record->EPB_epasEACAllow = 0;
	if (in < 4)
		return false;
	record->EPB_epasEACAllow = in;
	return true;
}

int print_can_0x214_EPB_epasControl(can_0x214_EPB_epasControl_t *print, FILE *data)
{
	int r = 0;
	r = phelper(r, fprintf(data, "EPB_epasControlChecksum = (wire: %.0f)\n", (double)(print->EPB_epasControlChecksum)));
	r = phelper(r, fprintf(data, "EPB_epasControlCounter = (wire: %.0f)\n", (double)(print->EPB_epasControlCounter)));
	r = phelper(r, fprintf(data, "EPB_epasEACAllow = (wire: %.0f)\n", (double)(print->EPB_epasEACAllow)));
	return r;
}

int pack_can_0x283_BODY_R1(can_0x283_BODY_R1_t *pack, uint64_t *data)
{
	register uint64_t x;
	register uint64_t m = 0;
	/* AirTemp_Insd: start-bit 47, length 8, endianess motorola, scaling 0.25, offset 0 */
	x = ((uint8_t)(pack->AirTemp_Insd)) & 0xff;
	x <<= 16; 
	m |= x;
	/* AirTemp_Outsd: start-bit 63, length 8, endianess motorola, scaling 0.5, offset -40 */
	x = ((uint8_t)(pack->AirTemp_Outsd)) & 0xff;
	m |= x;
	/* LgtSens_Twlgt: start-bit 18, length 3, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->LgtSens_Twlgt)) & 0x7;
	x <<= 40; 
	m |= x;
	/* DrRLtch_FL_Stat: start-bit 1, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DrRLtch_FL_Stat)) & 0x3;
	x <<= 56; 
	m |= x;
	/* DrRLtch_FR_Stat: start-bit 3, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DrRLtch_FR_Stat)) & 0x3;
	x <<= 58; 
	m |= x;
	/* DrRLtch_RL_Stat: start-bit 5, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DrRLtch_RL_Stat)) & 0x3;
	x <<= 60; 
	m |= x;
	/* DrRLtch_RR_Stat: start-bit 7, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DrRLtch_RR_Stat)) & 0x3;
	x <<= 62; 
	m |= x;
	/* DL_RLtch_Stat: start-bit 9, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DL_RLtch_Stat)) & 0x3;
	x <<= 48; 
	m |= x;
	/* EngHd_Stat: start-bit 11, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->EngHd_Stat)) & 0x3;
	x <<= 50; 
	m |= x;
	/* Trlr_Stat: start-bit 25, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->Trlr_Stat)) & 0x3;
	x <<= 32; 
	m |= x;
	/* RevGr_Engg: start-bit 39, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->RevGr_Engg)) & 0x3;
	x <<= 30; 
	m |= x;
	/* Bckl_Sw_RL_Stat_SAM_R: start-bit 49, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->Bckl_Sw_RL_Stat_SAM_R)) & 0x3;
	x <<= 8; 
	m |= x;
	/* Bckl_Sw_RR_Stat_SAM_R: start-bit 51, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->Bckl_Sw_RR_Stat_SAM_R)) & 0x3;
	x <<= 10; 
	m |= x;
	/* Bckl_Sw_RM_Stat_SAM_R: start-bit 53, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->Bckl_Sw_RM_Stat_SAM_R)) & 0x3;
	x <<= 12; 
	m |= x;
	/* StW_Cond_Stat: start-bit 55, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->StW_Cond_Stat)) & 0x3;
	x <<= 14; 
	m |= x;
	/* VTA_Alm_Actv: start-bit 13, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->VTA_Alm_Actv)) & 0x1;
	x <<= 53; 
	m |= x;
	/* LgtSens_SNA: start-bit 19, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->LgtSens_SNA)) & 0x1;
	x <<= 43; 
	m |= x;
	/* LgtSens_Tunnel: start-bit 20, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->LgtSens_Tunnel)) & 0x1;
	x <<= 44; 
	m |= x;
	/* LgtSens_Flt: start-bit 21, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->LgtSens_Flt)) & 0x1;
	x <<= 45; 
	m |= x;
	/* LgtSens_Night: start-bit 22, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->LgtSens_Night)) & 0x1;
	x <<= 46; 
	m |= x;
	/* ADL_LoBm_On_Rq: start-bit 23, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->ADL_LoBm_On_Rq)) & 0x1;
	x <<= 47; 
	m |= x;
	/* Hrn_On: start-bit 26, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->Hrn_On)) & 0x1;
	x <<= 34; 
	m |= x;
	/* Term54_Actv: start-bit 27, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->Term54_Actv)) & 0x1;
	x <<= 35; 
	m |= x;
	/* MPkBrk_Stat: start-bit 28, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->MPkBrk_Stat)) & 0x1;
	x <<= 36; 
	m |= x;
	/* WprOutsdPkPosn: start-bit 29, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->WprOutsdPkPosn)) & 0x1;
	x <<= 37; 
	m |= x;
	/* LoBm_On_Rq: start-bit 32, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->LoBm_On_Rq)) & 0x1;
	x <<= 24; 
	m |= x;
	/* HiBm_On: start-bit 33, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->HiBm_On)) & 0x1;
	x <<= 25; 
	m |= x;
	/* IrLmp_D_Lt_Flt: start-bit 34, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->IrLmp_D_Lt_Flt)) & 0x1;
	x <<= 26; 
	m |= x;
	/* IrLmp_P_Rt_Flt: start-bit 35, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->IrLmp_P_Rt_Flt)) & 0x1;
	x <<= 27; 
	m |= x;
	/* LoBm_D_Lt_Flt: start-bit 36, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->LoBm_D_Lt_Flt)) & 0x1;
	x <<= 28; 
	m |= x;
	/* LoBm_P_Rt_Flt: start-bit 37, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->LoBm_P_Rt_Flt)) & 0x1;
	x <<= 29; 
	m |= x;
	*data = reverse_byte_order(m);
	return 0;
}

int unpack_can_0x283_BODY_R1(can_0x283_BODY_R1_t *unpack, uint64_t data, uint8_t dlc)
{
	register uint64_t x;
	register uint64_t m = reverse_byte_order(data);
	if (dlc < 8)
		return -1;
	/* AirTemp_Insd: start-bit 47, length 8, endianess motorola, scaling 0.25, offset 0 */
	x = (m >> 16) & 0xff;
	unpack->AirTemp_Insd = x;
	/* AirTemp_Outsd: start-bit 63, length 8, endianess motorola, scaling 0.5, offset -40 */
	x = m & 0xff;
	unpack->AirTemp_Outsd = x;
	/* LgtSens_Twlgt: start-bit 18, length 3, endianess motorola, scaling 1, offset 0 */
	x = (m >> 40) & 0x7;
	unpack->LgtSens_Twlgt = x;
	/* DrRLtch_FL_Stat: start-bit 1, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 56) & 0x3;
	unpack->DrRLtch_FL_Stat = x;
	/* DrRLtch_FR_Stat: start-bit 3, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 58) & 0x3;
	unpack->DrRLtch_FR_Stat = x;
	/* DrRLtch_RL_Stat: start-bit 5, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 60) & 0x3;
	unpack->DrRLtch_RL_Stat = x;
	/* DrRLtch_RR_Stat: start-bit 7, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 62) & 0x3;
	unpack->DrRLtch_RR_Stat = x;
	/* DL_RLtch_Stat: start-bit 9, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 48) & 0x3;
	unpack->DL_RLtch_Stat = x;
	/* EngHd_Stat: start-bit 11, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 50) & 0x3;
	unpack->EngHd_Stat = x;
	/* Trlr_Stat: start-bit 25, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 32) & 0x3;
	unpack->Trlr_Stat = x;
	/* RevGr_Engg: start-bit 39, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 30) & 0x3;
	unpack->RevGr_Engg = x;
	/* Bckl_Sw_RL_Stat_SAM_R: start-bit 49, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 8) & 0x3;
	unpack->Bckl_Sw_RL_Stat_SAM_R = x;
	/* Bckl_Sw_RR_Stat_SAM_R: start-bit 51, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 10) & 0x3;
	unpack->Bckl_Sw_RR_Stat_SAM_R = x;
	/* Bckl_Sw_RM_Stat_SAM_R: start-bit 53, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 12) & 0x3;
	unpack->Bckl_Sw_RM_Stat_SAM_R = x;
	/* StW_Cond_Stat: start-bit 55, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 14) & 0x3;
	unpack->StW_Cond_Stat = x;
	/* VTA_Alm_Actv: start-bit 13, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 53) & 0x1;
	unpack->VTA_Alm_Actv = x;
	/* LgtSens_SNA: start-bit 19, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 43) & 0x1;
	unpack->LgtSens_SNA = x;
	/* LgtSens_Tunnel: start-bit 20, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 44) & 0x1;
	unpack->LgtSens_Tunnel = x;
	/* LgtSens_Flt: start-bit 21, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 45) & 0x1;
	unpack->LgtSens_Flt = x;
	/* LgtSens_Night: start-bit 22, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 46) & 0x1;
	unpack->LgtSens_Night = x;
	/* ADL_LoBm_On_Rq: start-bit 23, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 47) & 0x1;
	unpack->ADL_LoBm_On_Rq = x;
	/* Hrn_On: start-bit 26, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 34) & 0x1;
	unpack->Hrn_On = x;
	/* Term54_Actv: start-bit 27, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 35) & 0x1;
	unpack->Term54_Actv = x;
	/* MPkBrk_Stat: start-bit 28, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 36) & 0x1;
	unpack->MPkBrk_Stat = x;
	/* WprOutsdPkPosn: start-bit 29, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 37) & 0x1;
	unpack->WprOutsdPkPosn = x;
	/* LoBm_On_Rq: start-bit 32, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 24) & 0x1;
	unpack->LoBm_On_Rq = x;
	/* HiBm_On: start-bit 33, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 25) & 0x1;
	unpack->HiBm_On = x;
	/* IrLmp_D_Lt_Flt: start-bit 34, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 26) & 0x1;
	unpack->IrLmp_D_Lt_Flt = x;
	/* IrLmp_P_Rt_Flt: start-bit 35, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 27) & 0x1;
	unpack->IrLmp_P_Rt_Flt = x;
	/* LoBm_D_Lt_Flt: start-bit 36, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 28) & 0x1;
	unpack->LoBm_D_Lt_Flt = x;
	/* LoBm_P_Rt_Flt: start-bit 37, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 29) & 0x1;
	unpack->LoBm_P_Rt_Flt = x;
	return 0;
}

bool decode_can_0x283_AirTemp_Insd(can_0x283_BODY_R1_t *record, double *out)
{
	double rval = (double)(record->AirTemp_Insd);
	rval *= 0.25;
	if (rval <= 63.5) {
		*out = rval;
		return true;
	} else {
		*out = (double)0;
		return false;
	}
}

bool encode_can_0x283_AirTemp_Insd(can_0x283_BODY_R1_t *record, double in)
{
	record->AirTemp_Insd = 0;
	if (in > 63.5)
		return false;
	in *= 4;
	record->AirTemp_Insd = in;
	return true;
}

bool decode_can_0x283_AirTemp_Outsd(can_0x283_BODY_R1_t *record, double *out)
{
	double rval = (double)(record->AirTemp_Outsd);
	rval *= 0.5;
	rval += -40;
	if (rval <= 86.5) {
		*out = rval;
		return true;
	} else {
		*out = (double)0;
		return false;
	}
}

bool encode_can_0x283_AirTemp_Outsd(can_0x283_BODY_R1_t *record, double in)
{
	record->AirTemp_Outsd = 0;
	if (in > 86.5)
		return false;
	in += 40;
	in *= 2;
	record->AirTemp_Outsd = in;
	return true;
}

bool decode_can_0x283_LgtSens_Twlgt(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->LgtSens_Twlgt);
	*out = rval;
	return true;
}

bool encode_can_0x283_LgtSens_Twlgt(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->LgtSens_Twlgt = in;
	return true;
}

bool decode_can_0x283_DrRLtch_FL_Stat(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DrRLtch_FL_Stat);
	*out = rval;
	return true;
}

bool encode_can_0x283_DrRLtch_FL_Stat(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->DrRLtch_FL_Stat = in;
	return true;
}

bool decode_can_0x283_DrRLtch_FR_Stat(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DrRLtch_FR_Stat);
	*out = rval;
	return true;
}

bool encode_can_0x283_DrRLtch_FR_Stat(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->DrRLtch_FR_Stat = in;
	return true;
}

bool decode_can_0x283_DrRLtch_RL_Stat(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DrRLtch_RL_Stat);
	*out = rval;
	return true;
}

bool encode_can_0x283_DrRLtch_RL_Stat(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->DrRLtch_RL_Stat = in;
	return true;
}

bool decode_can_0x283_DrRLtch_RR_Stat(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DrRLtch_RR_Stat);
	*out = rval;
	return true;
}

bool encode_can_0x283_DrRLtch_RR_Stat(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->DrRLtch_RR_Stat = in;
	return true;
}

bool decode_can_0x283_DL_RLtch_Stat(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DL_RLtch_Stat);
	*out = rval;
	return true;
}

bool encode_can_0x283_DL_RLtch_Stat(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->DL_RLtch_Stat = in;
	return true;
}

bool decode_can_0x283_EngHd_Stat(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->EngHd_Stat);
	*out = rval;
	return true;
}

bool encode_can_0x283_EngHd_Stat(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->EngHd_Stat = in;
	return true;
}

bool decode_can_0x283_Trlr_Stat(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->Trlr_Stat);
	*out = rval;
	return true;
}

bool encode_can_0x283_Trlr_Stat(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->Trlr_Stat = in;
	return true;
}

bool decode_can_0x283_RevGr_Engg(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->RevGr_Engg);
	*out = rval;
	return true;
}

bool encode_can_0x283_RevGr_Engg(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->RevGr_Engg = in;
	return true;
}

bool decode_can_0x283_Bckl_Sw_RL_Stat_SAM_R(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->Bckl_Sw_RL_Stat_SAM_R);
	*out = rval;
	return true;
}

bool encode_can_0x283_Bckl_Sw_RL_Stat_SAM_R(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->Bckl_Sw_RL_Stat_SAM_R = in;
	return true;
}

bool decode_can_0x283_Bckl_Sw_RR_Stat_SAM_R(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->Bckl_Sw_RR_Stat_SAM_R);
	*out = rval;
	return true;
}

bool encode_can_0x283_Bckl_Sw_RR_Stat_SAM_R(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->Bckl_Sw_RR_Stat_SAM_R = in;
	return true;
}

bool decode_can_0x283_Bckl_Sw_RM_Stat_SAM_R(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->Bckl_Sw_RM_Stat_SAM_R);
	*out = rval;
	return true;
}

bool encode_can_0x283_Bckl_Sw_RM_Stat_SAM_R(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->Bckl_Sw_RM_Stat_SAM_R = in;
	return true;
}

bool decode_can_0x283_StW_Cond_Stat(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->StW_Cond_Stat);
	*out = rval;
	return true;
}

bool encode_can_0x283_StW_Cond_Stat(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->StW_Cond_Stat = in;
	return true;
}

bool decode_can_0x283_VTA_Alm_Actv(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->VTA_Alm_Actv);
	*out = rval;
	return true;
}

bool encode_can_0x283_VTA_Alm_Actv(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->VTA_Alm_Actv = in;
	return true;
}

bool decode_can_0x283_LgtSens_SNA(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->LgtSens_SNA);
	*out = rval;
	return true;
}

bool encode_can_0x283_LgtSens_SNA(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->LgtSens_SNA = in;
	return true;
}

bool decode_can_0x283_LgtSens_Tunnel(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->LgtSens_Tunnel);
	*out = rval;
	return true;
}

bool encode_can_0x283_LgtSens_Tunnel(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->LgtSens_Tunnel = in;
	return true;
}

bool decode_can_0x283_LgtSens_Flt(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->LgtSens_Flt);
	*out = rval;
	return true;
}

bool encode_can_0x283_LgtSens_Flt(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->LgtSens_Flt = in;
	return true;
}

bool decode_can_0x283_LgtSens_Night(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->LgtSens_Night);
	*out = rval;
	return true;
}

bool encode_can_0x283_LgtSens_Night(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->LgtSens_Night = in;
	return true;
}

bool decode_can_0x283_ADL_LoBm_On_Rq(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->ADL_LoBm_On_Rq);
	*out = rval;
	return true;
}

bool encode_can_0x283_ADL_LoBm_On_Rq(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->ADL_LoBm_On_Rq = in;
	return true;
}

bool decode_can_0x283_Hrn_On(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->Hrn_On);
	*out = rval;
	return true;
}

bool encode_can_0x283_Hrn_On(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->Hrn_On = in;
	return true;
}

bool decode_can_0x283_Term54_Actv(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->Term54_Actv);
	*out = rval;
	return true;
}

bool encode_can_0x283_Term54_Actv(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->Term54_Actv = in;
	return true;
}

bool decode_can_0x283_MPkBrk_Stat(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->MPkBrk_Stat);
	*out = rval;
	return true;
}

bool encode_can_0x283_MPkBrk_Stat(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->MPkBrk_Stat = in;
	return true;
}

bool decode_can_0x283_WprOutsdPkPosn(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->WprOutsdPkPosn);
	*out = rval;
	return true;
}

bool encode_can_0x283_WprOutsdPkPosn(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->WprOutsdPkPosn = in;
	return true;
}

bool decode_can_0x283_LoBm_On_Rq(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->LoBm_On_Rq);
	*out = rval;
	return true;
}

bool encode_can_0x283_LoBm_On_Rq(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->LoBm_On_Rq = in;
	return true;
}

bool decode_can_0x283_HiBm_On(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->HiBm_On);
	*out = rval;
	return true;
}

bool encode_can_0x283_HiBm_On(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->HiBm_On = in;
	return true;
}

bool decode_can_0x283_IrLmp_D_Lt_Flt(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->IrLmp_D_Lt_Flt);
	*out = rval;
	return true;
}

bool encode_can_0x283_IrLmp_D_Lt_Flt(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->IrLmp_D_Lt_Flt = in;
	return true;
}

bool decode_can_0x283_IrLmp_P_Rt_Flt(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->IrLmp_P_Rt_Flt);
	*out = rval;
	return true;
}

bool encode_can_0x283_IrLmp_P_Rt_Flt(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->IrLmp_P_Rt_Flt = in;
	return true;
}

bool decode_can_0x283_LoBm_D_Lt_Flt(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->LoBm_D_Lt_Flt);
	*out = rval;
	return true;
}

bool encode_can_0x283_LoBm_D_Lt_Flt(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->LoBm_D_Lt_Flt = in;
	return true;
}

bool decode_can_0x283_LoBm_P_Rt_Flt(can_0x283_BODY_R1_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->LoBm_P_Rt_Flt);
	*out = rval;
	return true;
}

bool encode_can_0x283_LoBm_P_Rt_Flt(can_0x283_BODY_R1_t *record, uint8_t in)
{
	record->LoBm_P_Rt_Flt = in;
	return true;
}

int print_can_0x283_BODY_R1(can_0x283_BODY_R1_t *print, FILE *data)
{
	int r = 0;
	r = phelper(r, fprintf(data, "AirTemp_Insd = (wire: %.0f)\n", (double)(print->AirTemp_Insd)));
	r = phelper(r, fprintf(data, "AirTemp_Outsd = (wire: %.0f)\n", (double)(print->AirTemp_Outsd)));
	r = phelper(r, fprintf(data, "LgtSens_Twlgt = (wire: %.0f)\n", (double)(print->LgtSens_Twlgt)));
	r = phelper(r, fprintf(data, "DrRLtch_FL_Stat = (wire: %.0f)\n", (double)(print->DrRLtch_FL_Stat)));
	r = phelper(r, fprintf(data, "DrRLtch_FR_Stat = (wire: %.0f)\n", (double)(print->DrRLtch_FR_Stat)));
	r = phelper(r, fprintf(data, "DrRLtch_RL_Stat = (wire: %.0f)\n", (double)(print->DrRLtch_RL_Stat)));
	r = phelper(r, fprintf(data, "DrRLtch_RR_Stat = (wire: %.0f)\n", (double)(print->DrRLtch_RR_Stat)));
	r = phelper(r, fprintf(data, "DL_RLtch_Stat = (wire: %.0f)\n", (double)(print->DL_RLtch_Stat)));
	r = phelper(r, fprintf(data, "EngHd_Stat = (wire: %.0f)\n", (double)(print->EngHd_Stat)));
	r = phelper(r, fprintf(data, "Trlr_Stat = (wire: %.0f)\n", (double)(print->Trlr_Stat)));
	r = phelper(r, fprintf(data, "RevGr_Engg = (wire: %.0f)\n", (double)(print->RevGr_Engg)));
	r = phelper(r, fprintf(data, "Bckl_Sw_RL_Stat_SAM_R = (wire: %.0f)\n", (double)(print->Bckl_Sw_RL_Stat_SAM_R)));
	r = phelper(r, fprintf(data, "Bckl_Sw_RR_Stat_SAM_R = (wire: %.0f)\n", (double)(print->Bckl_Sw_RR_Stat_SAM_R)));
	r = phelper(r, fprintf(data, "Bckl_Sw_RM_Stat_SAM_R = (wire: %.0f)\n", (double)(print->Bckl_Sw_RM_Stat_SAM_R)));
	r = phelper(r, fprintf(data, "StW_Cond_Stat = (wire: %.0f)\n", (double)(print->StW_Cond_Stat)));
	r = phelper(r, fprintf(data, "VTA_Alm_Actv = (wire: %.0f)\n", (double)(print->VTA_Alm_Actv)));
	r = phelper(r, fprintf(data, "LgtSens_SNA = (wire: %.0f)\n", (double)(print->LgtSens_SNA)));
	r = phelper(r, fprintf(data, "LgtSens_Tunnel = (wire: %.0f)\n", (double)(print->LgtSens_Tunnel)));
	r = phelper(r, fprintf(data, "LgtSens_Flt = (wire: %.0f)\n", (double)(print->LgtSens_Flt)));
	r = phelper(r, fprintf(data, "LgtSens_Night = (wire: %.0f)\n", (double)(print->LgtSens_Night)));
	r = phelper(r, fprintf(data, "ADL_LoBm_On_Rq = (wire: %.0f)\n", (double)(print->ADL_LoBm_On_Rq)));
	r = phelper(r, fprintf(data, "Hrn_On = (wire: %.0f)\n", (double)(print->Hrn_On)));
	r = phelper(r, fprintf(data, "Term54_Actv = (wire: %.0f)\n", (double)(print->Term54_Actv)));
	r = phelper(r, fprintf(data, "MPkBrk_Stat = (wire: %.0f)\n", (double)(print->MPkBrk_Stat)));
	r = phelper(r, fprintf(data, "WprOutsdPkPosn = (wire: %.0f)\n", (double)(print->WprOutsdPkPosn)));
	r = phelper(r, fprintf(data, "LoBm_On_Rq = (wire: %.0f)\n", (double)(print->LoBm_On_Rq)));
	r = phelper(r, fprintf(data, "HiBm_On = (wire: %.0f)\n", (double)(print->HiBm_On)));
	r = phelper(r, fprintf(data, "IrLmp_D_Lt_Flt = (wire: %.0f)\n", (double)(print->IrLmp_D_Lt_Flt)));
	r = phelper(r, fprintf(data, "IrLmp_P_Rt_Flt = (wire: %.0f)\n", (double)(print->IrLmp_P_Rt_Flt)));
	r = phelper(r, fprintf(data, "LoBm_D_Lt_Flt = (wire: %.0f)\n", (double)(print->LoBm_D_Lt_Flt)));
	r = phelper(r, fprintf(data, "LoBm_P_Rt_Flt = (wire: %.0f)\n", (double)(print->LoBm_P_Rt_Flt)));
	return r;
}

int pack_can_0x2f8_MCU_gpsVehicleSpeed(can_0x2f8_MCU_gpsVehicleSpeed_t *pack, uint64_t *data)
{
	register uint64_t x;
	register uint64_t i = 0;
	/* MCU_gpsVehicleHeading: start-bit 8, length 16, endianess intel, scaling 0.00781, offset 0 */
	x = ((uint16_t)(pack->MCU_gpsVehicleHeading)) & 0xffff;
	x <<= 8; 
	i |= x;
	/* MCU_gpsVehicleSpeed: start-bit 24, length 16, endianess intel, scaling 0.00391, offset 0 */
	x = ((uint16_t)(pack->MCU_gpsVehicleSpeed)) & 0xffff;
	x <<= 24; 
	i |= x;
	/* MCU_gpsHDOP: start-bit 0, length 8, endianess intel, scaling 0.1, offset 0 */
	x = ((uint8_t)(pack->MCU_gpsHDOP)) & 0xff;
	i |= x;
	/* MCU_userSpeedOffset: start-bit 42, length 6, endianess intel, scaling 1, offset -30 */
	x = ((uint8_t)(pack->MCU_userSpeedOffset)) & 0x3f;
	x <<= 42; 
	i |= x;
	/* MCU_mppSpeedLimit: start-bit 51, length 5, endianess intel, scaling 5, offset 0 */
	x = ((uint8_t)(pack->MCU_mppSpeedLimit)) & 0x1f;
	x <<= 51; 
	i |= x;
	/* MCU_userSpeedOffsetUnits: start-bit 40, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->MCU_userSpeedOffsetUnits)) & 0x1;
	x <<= 40; 
	i |= x;
	/* MCU_speedLimitUnits: start-bit 41, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->MCU_speedLimitUnits)) & 0x1;
	x <<= 41; 
	i |= x;
	*data = (i);
	return 0;
}

int unpack_can_0x2f8_MCU_gpsVehicleSpeed(can_0x2f8_MCU_gpsVehicleSpeed_t *unpack, uint64_t data, uint8_t dlc)
{
	register uint64_t x;
	register uint64_t i = (data);
	if (dlc < 8)
		return -1;
	/* MCU_gpsVehicleHeading: start-bit 8, length 16, endianess intel, scaling 0.00781, offset 0 */
	x = (i >> 8) & 0xffff;
	unpack->MCU_gpsVehicleHeading = x;
	/* MCU_gpsVehicleSpeed: start-bit 24, length 16, endianess intel, scaling 0.00391, offset 0 */
	x = (i >> 24) & 0xffff;
	unpack->MCU_gpsVehicleSpeed = x;
	/* MCU_gpsHDOP: start-bit 0, length 8, endianess intel, scaling 0.1, offset 0 */
	x = i & 0xff;
	unpack->MCU_gpsHDOP = x;
	/* MCU_userSpeedOffset: start-bit 42, length 6, endianess intel, scaling 1, offset -30 */
	x = (i >> 42) & 0x3f;
	unpack->MCU_userSpeedOffset = x;
	/* MCU_mppSpeedLimit: start-bit 51, length 5, endianess intel, scaling 5, offset 0 */
	x = (i >> 51) & 0x1f;
	unpack->MCU_mppSpeedLimit = x;
	/* MCU_userSpeedOffsetUnits: start-bit 40, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 40) & 0x1;
	unpack->MCU_userSpeedOffsetUnits = x;
	/* MCU_speedLimitUnits: start-bit 41, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 41) & 0x1;
	unpack->MCU_speedLimitUnits = x;
	return 0;
}

bool decode_can_0x2f8_MCU_gpsVehicleHeading(can_0x2f8_MCU_gpsVehicleSpeed_t *record, double *out)
{
	double rval = (double)(record->MCU_gpsVehicleHeading);
	rval *= 0.00781;
	if (rval <= 511.828) {
		*out = rval;
		return true;
	} else {
		*out = (double)0;
		return false;
	}
}

bool encode_can_0x2f8_MCU_gpsVehicleHeading(can_0x2f8_MCU_gpsVehicleSpeed_t *record, double in)
{
	record->MCU_gpsVehicleHeading = 0;
	if (in > 511.828)
		return false;
	in *= 128.041;
	record->MCU_gpsVehicleHeading = in;
	return true;
}

bool decode_can_0x2f8_MCU_gpsVehicleSpeed(can_0x2f8_MCU_gpsVehicleSpeed_t *record, double *out)
{
	double rval = (double)(record->MCU_gpsVehicleSpeed);
	rval *= 0.00391;
	if (rval <= 256.242) {
		*out = rval;
		return true;
	} else {
		*out = (double)0;
		return false;
	}
}

bool encode_can_0x2f8_MCU_gpsVehicleSpeed(can_0x2f8_MCU_gpsVehicleSpeed_t *record, double in)
{
	record->MCU_gpsVehicleSpeed = 0;
	if (in > 256.242)
		return false;
	in *= 255.754;
	record->MCU_gpsVehicleSpeed = in;
	return true;
}

bool decode_can_0x2f8_MCU_gpsHDOP(can_0x2f8_MCU_gpsVehicleSpeed_t *record, double *out)
{
	double rval = (double)(record->MCU_gpsHDOP);
	rval *= 0.1;
	if (rval <= 25.5) {
		*out = rval;
		return true;
	} else {
		*out = (double)0;
		return false;
	}
}

bool encode_can_0x2f8_MCU_gpsHDOP(can_0x2f8_MCU_gpsVehicleSpeed_t *record, double in)
{
	record->MCU_gpsHDOP = 0;
	if (in > 25.5)
		return false;
	in *= 10;
	record->MCU_gpsHDOP = in;
	return true;
}

bool decode_can_0x2f8_MCU_userSpeedOffset(can_0x2f8_MCU_gpsVehicleSpeed_t *record, double *out)
{
	double rval = (double)(record->MCU_userSpeedOffset);
	rval += -30;
	if (rval <= 33) {
		*out = rval;
		return true;
	} else {
		*out = (double)0;
		return false;
	}
}

bool encode_can_0x2f8_MCU_userSpeedOffset(can_0x2f8_MCU_gpsVehicleSpeed_t *record, double in)
{
	record->MCU_userSpeedOffset = 0;
	if (in > 33)
		return false;
	in += 30;
	record->MCU_userSpeedOffset = in;
	return true;
}

bool decode_can_0x2f8_MCU_mppSpeedLimit(can_0x2f8_MCU_gpsVehicleSpeed_t *record, double *out)
{
	double rval = (double)(record->MCU_mppSpeedLimit);
	rval *= 5;
	*out = rval;
	return true;
}

bool encode_can_0x2f8_MCU_mppSpeedLimit(can_0x2f8_MCU_gpsVehicleSpeed_t *record, double in)
{
	in *= 0.2;
	record->MCU_mppSpeedLimit = in;
	return true;
}

bool decode_can_0x2f8_MCU_userSpeedOffsetUnits(can_0x2f8_MCU_gpsVehicleSpeed_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->MCU_userSpeedOffsetUnits);
	*out = rval;
	return true;
}

bool encode_can_0x2f8_MCU_userSpeedOffsetUnits(can_0x2f8_MCU_gpsVehicleSpeed_t *record, uint8_t in)
{
	record->MCU_userSpeedOffsetUnits = in;
	return true;
}

bool decode_can_0x2f8_MCU_speedLimitUnits(can_0x2f8_MCU_gpsVehicleSpeed_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->MCU_speedLimitUnits);
	*out = rval;
	return true;
}

bool encode_can_0x2f8_MCU_speedLimitUnits(can_0x2f8_MCU_gpsVehicleSpeed_t *record, uint8_t in)
{
	record->MCU_speedLimitUnits = in;
	return true;
}

int print_can_0x2f8_MCU_gpsVehicleSpeed(can_0x2f8_MCU_gpsVehicleSpeed_t *print, FILE *data)
{
	int r = 0;
	r = phelper(r, fprintf(data, "MCU_gpsVehicleHeading = (wire: %.0f)\n", (double)(print->MCU_gpsVehicleHeading)));
	r = phelper(r, fprintf(data, "MCU_gpsVehicleSpeed = (wire: %.0f)\n", (double)(print->MCU_gpsVehicleSpeed)));
	r = phelper(r, fprintf(data, "MCU_gpsHDOP = (wire: %.0f)\n", (double)(print->MCU_gpsHDOP)));
	r = phelper(r, fprintf(data, "MCU_userSpeedOffset = (wire: %.0f)\n", (double)(print->MCU_userSpeedOffset)));
	r = phelper(r, fprintf(data, "MCU_mppSpeedLimit = (wire: %.0f)\n", (double)(print->MCU_mppSpeedLimit)));
	r = phelper(r, fprintf(data, "MCU_userSpeedOffsetUnits = (wire: %.0f)\n", (double)(print->MCU_userSpeedOffsetUnits)));
	r = phelper(r, fprintf(data, "MCU_speedLimitUnits = (wire: %.0f)\n", (double)(print->MCU_speedLimitUnits)));
	return r;
}

int pack_can_0x318_GTW_carState(can_0x318_GTW_carState_t *pack, uint64_t *data)
{
	register uint64_t x;
	register uint64_t m = 0;
	/* YEAR: start-bit 6, length 7, endianess motorola, scaling 1, offset 2000 */
	x = ((uint8_t)(pack->YEAR)) & 0x7f;
	x <<= 56; 
	m |= x;
	/* SECOND: start-bit 21, length 6, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->SECOND)) & 0x3f;
	x <<= 40; 
	m |= x;
	/* MINUTE: start-bit 45, length 6, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->MINUTE)) & 0x3f;
	x <<= 16; 
	m |= x;
	/* Hour: start-bit 28, length 5, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->Hour)) & 0x1f;
	x <<= 32; 
	m |= x;
	/* DAY: start-bit 36, length 5, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DAY)) & 0x1f;
	x <<= 24; 
	m |= x;
	/* MONTH: start-bit 11, length 4, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->MONTH)) & 0xf;
	x <<= 48; 
	m |= x;
	/* DOOR_STATE_FL: start-bit 13, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DOOR_STATE_FL)) & 0x3;
	x <<= 52; 
	m |= x;
	/* DOOR_STATE_FR: start-bit 15, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DOOR_STATE_FR)) & 0x3;
	x <<= 54; 
	m |= x;
	/* DOOR_STATE_RL: start-bit 23, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DOOR_STATE_RL)) & 0x3;
	x <<= 46; 
	m |= x;
	/* DOOR_STATE_RR: start-bit 30, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DOOR_STATE_RR)) & 0x3;
	x <<= 37; 
	m |= x;
	/* BOOT_STATE: start-bit 47, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->BOOT_STATE)) & 0x3;
	x <<= 22; 
	m |= x;
	/* GTW_updateInProgress: start-bit 49, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->GTW_updateInProgress)) & 0x3;
	x <<= 8; 
	m |= x;
	/* DOOR_STATE_FrontTrunk: start-bit 51, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DOOR_STATE_FrontTrunk)) & 0x3;
	x <<= 10; 
	m |= x;
	/* CERRD: start-bit 7, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->CERRD)) & 0x1;
	x <<= 63; 
	m |= x;
	/* MCU_factoryMode: start-bit 52, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->MCU_factoryMode)) & 0x1;
	x <<= 12; 
	m |= x;
	/* MCU_transportModeOn: start-bit 53, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->MCU_transportModeOn)) & 0x1;
	x <<= 13; 
	m |= x;
	*data = reverse_byte_order(m);
	return 0;
}

int unpack_can_0x318_GTW_carState(can_0x318_GTW_carState_t *unpack, uint64_t data, uint8_t dlc)
{
	register uint64_t x;
	register uint64_t m = reverse_byte_order(data);
	if (dlc < 8)
		return -1;
	/* YEAR: start-bit 6, length 7, endianess motorola, scaling 1, offset 2000 */
	x = (m >> 56) & 0x7f;
	unpack->YEAR = x;
	/* SECOND: start-bit 21, length 6, endianess motorola, scaling 1, offset 0 */
	x = (m >> 40) & 0x3f;
	unpack->SECOND = x;
	/* MINUTE: start-bit 45, length 6, endianess motorola, scaling 1, offset 0 */
	x = (m >> 16) & 0x3f;
	unpack->MINUTE = x;
	/* Hour: start-bit 28, length 5, endianess motorola, scaling 1, offset 0 */
	x = (m >> 32) & 0x1f;
	unpack->Hour = x;
	/* DAY: start-bit 36, length 5, endianess motorola, scaling 1, offset 0 */
	x = (m >> 24) & 0x1f;
	unpack->DAY = x;
	/* MONTH: start-bit 11, length 4, endianess motorola, scaling 1, offset 0 */
	x = (m >> 48) & 0xf;
	unpack->MONTH = x;
	/* DOOR_STATE_FL: start-bit 13, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 52) & 0x3;
	unpack->DOOR_STATE_FL = x;
	/* DOOR_STATE_FR: start-bit 15, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 54) & 0x3;
	unpack->DOOR_STATE_FR = x;
	/* DOOR_STATE_RL: start-bit 23, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 46) & 0x3;
	unpack->DOOR_STATE_RL = x;
	/* DOOR_STATE_RR: start-bit 30, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 37) & 0x3;
	unpack->DOOR_STATE_RR = x;
	/* BOOT_STATE: start-bit 47, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 22) & 0x3;
	unpack->BOOT_STATE = x;
	/* GTW_updateInProgress: start-bit 49, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 8) & 0x3;
	unpack->GTW_updateInProgress = x;
	/* DOOR_STATE_FrontTrunk: start-bit 51, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 10) & 0x3;
	unpack->DOOR_STATE_FrontTrunk = x;
	/* CERRD: start-bit 7, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 63) & 0x1;
	unpack->CERRD = x;
	/* MCU_factoryMode: start-bit 52, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 12) & 0x1;
	unpack->MCU_factoryMode = x;
	/* MCU_transportModeOn: start-bit 53, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 13) & 0x1;
	unpack->MCU_transportModeOn = x;
	return 0;
}

bool decode_can_0x318_YEAR(can_0x318_GTW_carState_t *record, double *out)
{
	double rval = (double)(record->YEAR);
	rval += 2000;
	if (rval >= 2000) {
		*out = rval;
		return true;
	} else {
		*out = (double)0;
		return false;
	}
}

bool encode_can_0x318_YEAR(can_0x318_GTW_carState_t *record, double in)
{
	record->YEAR = 0;
	if (in < 2000)
		return false;
	in += -2000;
	record->YEAR = in;
	return true;
}

bool decode_can_0x318_SECOND(can_0x318_GTW_carState_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->SECOND);
	if (rval <= 61) {
		*out = rval;
		return true;
	} else {
		*out = (uint8_t)0;
		return false;
	}
}

bool encode_can_0x318_SECOND(can_0x318_GTW_carState_t *record, uint8_t in)
{
	record->SECOND = 0;
	if (in > 61)
		return false;
	record->SECOND = in;
	return true;
}

bool decode_can_0x318_MINUTE(can_0x318_GTW_carState_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->MINUTE);
	if (rval <= 61) {
		*out = rval;
		return true;
	} else {
		*out = (uint8_t)0;
		return false;
	}
}

bool encode_can_0x318_MINUTE(can_0x318_GTW_carState_t *record, uint8_t in)
{
	record->MINUTE = 0;
	if (in > 61)
		return false;
	record->MINUTE = in;
	return true;
}

bool decode_can_0x318_Hour(can_0x318_GTW_carState_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->Hour);
	if (rval <= 29) {
		*out = rval;
		return true;
	} else {
		*out = (uint8_t)0;
		return false;
	}
}

bool encode_can_0x318_Hour(can_0x318_GTW_carState_t *record, uint8_t in)
{
	record->Hour = 0;
	if (in > 29)
		return false;
	record->Hour = in;
	return true;
}

bool decode_can_0x318_DAY(can_0x318_GTW_carState_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DAY);
	if (rval >= 2) {
		*out = rval;
		return true;
	} else {
		*out = (uint8_t)0;
		return false;
	}
}

bool encode_can_0x318_DAY(can_0x318_GTW_carState_t *record, uint8_t in)
{
	record->DAY = 0;
	if (in < 2)
		return false;
	record->DAY = in;
	return true;
}

bool decode_can_0x318_MONTH(can_0x318_GTW_carState_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->MONTH);
	if (rval <= 14) {
		*out = rval;
		return true;
	} else {
		*out = (uint8_t)0;
		return false;
	}
}

bool encode_can_0x318_MONTH(can_0x318_GTW_carState_t *record, uint8_t in)
{
	record->MONTH = 0;
	if (in > 14)
		return false;
	record->MONTH = in;
	return true;
}

bool decode_can_0x318_DOOR_STATE_FL(can_0x318_GTW_carState_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DOOR_STATE_FL);
	*out = rval;
	return true;
}

bool encode_can_0x318_DOOR_STATE_FL(can_0x318_GTW_carState_t *record, uint8_t in)
{
	record->DOOR_STATE_FL = in;
	return true;
}

bool decode_can_0x318_DOOR_STATE_FR(can_0x318_GTW_carState_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DOOR_STATE_FR);
	*out = rval;
	return true;
}

bool encode_can_0x318_DOOR_STATE_FR(can_0x318_GTW_carState_t *record, uint8_t in)
{
	record->DOOR_STATE_FR = in;
	return true;
}

bool decode_can_0x318_DOOR_STATE_RL(can_0x318_GTW_carState_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DOOR_STATE_RL);
	*out = rval;
	return true;
}

bool encode_can_0x318_DOOR_STATE_RL(can_0x318_GTW_carState_t *record, uint8_t in)
{
	record->DOOR_STATE_RL = in;
	return true;
}

bool decode_can_0x318_DOOR_STATE_RR(can_0x318_GTW_carState_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DOOR_STATE_RR);
	*out = rval;
	return true;
}

bool encode_can_0x318_DOOR_STATE_RR(can_0x318_GTW_carState_t *record, uint8_t in)
{
	record->DOOR_STATE_RR = in;
	return true;
}

bool decode_can_0x318_BOOT_STATE(can_0x318_GTW_carState_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->BOOT_STATE);
	*out = rval;
	return true;
}

bool encode_can_0x318_BOOT_STATE(can_0x318_GTW_carState_t *record, uint8_t in)
{
	record->BOOT_STATE = in;
	return true;
}

bool decode_can_0x318_GTW_updateInProgress(can_0x318_GTW_carState_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->GTW_updateInProgress);
	*out = rval;
	return true;
}

bool encode_can_0x318_GTW_updateInProgress(can_0x318_GTW_carState_t *record, uint8_t in)
{
	record->GTW_updateInProgress = in;
	return true;
}

bool decode_can_0x318_DOOR_STATE_FrontTrunk(can_0x318_GTW_carState_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DOOR_STATE_FrontTrunk);
	*out = rval;
	return true;
}

bool encode_can_0x318_DOOR_STATE_FrontTrunk(can_0x318_GTW_carState_t *record, uint8_t in)
{
	record->DOOR_STATE_FrontTrunk = in;
	return true;
}

bool decode_can_0x318_CERRD(can_0x318_GTW_carState_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->CERRD);
	*out = rval;
	return true;
}

bool encode_can_0x318_CERRD(can_0x318_GTW_carState_t *record, uint8_t in)
{
	record->CERRD = in;
	return true;
}

bool decode_can_0x318_MCU_factoryMode(can_0x318_GTW_carState_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->MCU_factoryMode);
	*out = rval;
	return true;
}

bool encode_can_0x318_MCU_factoryMode(can_0x318_GTW_carState_t *record, uint8_t in)
{
	record->MCU_factoryMode = in;
	return true;
}

bool decode_can_0x318_MCU_transportModeOn(can_0x318_GTW_carState_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->MCU_transportModeOn);
	*out = rval;
	return true;
}

bool encode_can_0x318_MCU_transportModeOn(can_0x318_GTW_carState_t *record, uint8_t in)
{
	record->MCU_transportModeOn = in;
	return true;
}

int print_can_0x318_GTW_carState(can_0x318_GTW_carState_t *print, FILE *data)
{
	int r = 0;
	r = phelper(r, fprintf(data, "YEAR = (wire: %.0f)\n", (double)(print->YEAR)));
	r = phelper(r, fprintf(data, "SECOND = (wire: %.0f)\n", (double)(print->SECOND)));
	r = phelper(r, fprintf(data, "MINUTE = (wire: %.0f)\n", (double)(print->MINUTE)));
	r = phelper(r, fprintf(data, "Hour = (wire: %.0f)\n", (double)(print->Hour)));
	r = phelper(r, fprintf(data, "DAY = (wire: %.0f)\n", (double)(print->DAY)));
	r = phelper(r, fprintf(data, "MONTH = (wire: %.0f)\n", (double)(print->MONTH)));
	r = phelper(r, fprintf(data, "DOOR_STATE_FL = (wire: %.0f)\n", (double)(print->DOOR_STATE_FL)));
	r = phelper(r, fprintf(data, "DOOR_STATE_FR = (wire: %.0f)\n", (double)(print->DOOR_STATE_FR)));
	r = phelper(r, fprintf(data, "DOOR_STATE_RL = (wire: %.0f)\n", (double)(print->DOOR_STATE_RL)));
	r = phelper(r, fprintf(data, "DOOR_STATE_RR = (wire: %.0f)\n", (double)(print->DOOR_STATE_RR)));
	r = phelper(r, fprintf(data, "BOOT_STATE = (wire: %.0f)\n", (double)(print->BOOT_STATE)));
	r = phelper(r, fprintf(data, "GTW_updateInProgress = (wire: %.0f)\n", (double)(print->GTW_updateInProgress)));
	r = phelper(r, fprintf(data, "DOOR_STATE_FrontTrunk = (wire: %.0f)\n", (double)(print->DOOR_STATE_FrontTrunk)));
	r = phelper(r, fprintf(data, "CERRD = (wire: %.0f)\n", (double)(print->CERRD)));
	r = phelper(r, fprintf(data, "MCU_factoryMode = (wire: %.0f)\n", (double)(print->MCU_factoryMode)));
	r = phelper(r, fprintf(data, "MCU_transportModeOn = (wire: %.0f)\n", (double)(print->MCU_transportModeOn)));
	return r;
}

int pack_can_0x348_GTW_status(can_0x348_GTW_status_t *pack, uint64_t *data)
{
	register uint64_t x;
	register uint64_t m = 0;
	/* GTW_statusChecksum: start-bit 63, length 8, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->GTW_statusChecksum)) & 0xff;
	m |= x;
	/* GTW_statusCounter: start-bit 51, length 4, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->GTW_statusCounter)) & 0xf;
	x <<= 8; 
	m |= x;
	/* GTW_driveRailReq: start-bit 0, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->GTW_driveRailReq)) & 0x1;
	x <<= 56; 
	m |= x;
	/* GTW_brakePressed: start-bit 1, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->GTW_brakePressed)) & 0x1;
	x <<= 57; 
	m |= x;
	/* GTW_driverPresent: start-bit 2, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->GTW_driverPresent)) & 0x1;
	x <<= 58; 
	m |= x;
	/* GTW_notEnough12VForDrive: start-bit 3, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->GTW_notEnough12VForDrive)) & 0x1;
	x <<= 59; 
	m |= x;
	/* GTW_icPowerOff: start-bit 4, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->GTW_icPowerOff)) & 0x1;
	x <<= 60; 
	m |= x;
	/* GTW_driverIsLeaving: start-bit 5, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->GTW_driverIsLeaving)) & 0x1;
	x <<= 61; 
	m |= x;
	/* GTW_accGoingDown: start-bit 6, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->GTW_accGoingDown)) & 0x1;
	x <<= 62; 
	m |= x;
	/* GTW_driveGoingDown: start-bit 7, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->GTW_driveGoingDown)) & 0x1;
	x <<= 63; 
	m |= x;
	/* GTW_accRailReq: start-bit 8, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->GTW_accRailReq)) & 0x1;
	x <<= 48; 
	m |= x;
	/* GTW_hvacRailReq: start-bit 9, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->GTW_hvacRailReq)) & 0x1;
	x <<= 49; 
	m |= x;
	/* GTW_preconditionRequest: start-bit 10, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->GTW_preconditionRequest)) & 0x1;
	x <<= 50; 
	m |= x;
	/* GTW_hvacGoingDown: start-bit 11, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->GTW_hvacGoingDown)) & 0x1;
	x <<= 51; 
	m |= x;
	*data = reverse_byte_order(m);
	return 0;
}

int unpack_can_0x348_GTW_status(can_0x348_GTW_status_t *unpack, uint64_t data, uint8_t dlc)
{
	register uint64_t x;
	register uint64_t m = reverse_byte_order(data);
	if (dlc < 8)
		return -1;
	/* GTW_statusChecksum: start-bit 63, length 8, endianess motorola, scaling 1, offset 0 */
	x = m & 0xff;
	unpack->GTW_statusChecksum = x;
	/* GTW_statusCounter: start-bit 51, length 4, endianess motorola, scaling 1, offset 0 */
	x = (m >> 8) & 0xf;
	unpack->GTW_statusCounter = x;
	/* GTW_driveRailReq: start-bit 0, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 56) & 0x1;
	unpack->GTW_driveRailReq = x;
	/* GTW_brakePressed: start-bit 1, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 57) & 0x1;
	unpack->GTW_brakePressed = x;
	/* GTW_driverPresent: start-bit 2, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 58) & 0x1;
	unpack->GTW_driverPresent = x;
	/* GTW_notEnough12VForDrive: start-bit 3, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 59) & 0x1;
	unpack->GTW_notEnough12VForDrive = x;
	/* GTW_icPowerOff: start-bit 4, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 60) & 0x1;
	unpack->GTW_icPowerOff = x;
	/* GTW_driverIsLeaving: start-bit 5, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 61) & 0x1;
	unpack->GTW_driverIsLeaving = x;
	/* GTW_accGoingDown: start-bit 6, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 62) & 0x1;
	unpack->GTW_accGoingDown = x;
	/* GTW_driveGoingDown: start-bit 7, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 63) & 0x1;
	unpack->GTW_driveGoingDown = x;
	/* GTW_accRailReq: start-bit 8, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 48) & 0x1;
	unpack->GTW_accRailReq = x;
	/* GTW_hvacRailReq: start-bit 9, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 49) & 0x1;
	unpack->GTW_hvacRailReq = x;
	/* GTW_preconditionRequest: start-bit 10, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 50) & 0x1;
	unpack->GTW_preconditionRequest = x;
	/* GTW_hvacGoingDown: start-bit 11, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 51) & 0x1;
	unpack->GTW_hvacGoingDown = x;
	return 0;
}

bool decode_can_0x348_GTW_statusChecksum(can_0x348_GTW_status_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->GTW_statusChecksum);
	*out = rval;
	return true;
}

bool encode_can_0x348_GTW_statusChecksum(can_0x348_GTW_status_t *record, uint8_t in)
{
	record->GTW_statusChecksum = in;
	return true;
}

bool decode_can_0x348_GTW_statusCounter(can_0x348_GTW_status_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->GTW_statusCounter);
	*out = rval;
	return true;
}

bool encode_can_0x348_GTW_statusCounter(can_0x348_GTW_status_t *record, uint8_t in)
{
	record->GTW_statusCounter = in;
	return true;
}

bool decode_can_0x348_GTW_driveRailReq(can_0x348_GTW_status_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->GTW_driveRailReq);
	*out = rval;
	return true;
}

bool encode_can_0x348_GTW_driveRailReq(can_0x348_GTW_status_t *record, uint8_t in)
{
	record->GTW_driveRailReq = in;
	return true;
}

bool decode_can_0x348_GTW_brakePressed(can_0x348_GTW_status_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->GTW_brakePressed);
	*out = rval;
	return true;
}

bool encode_can_0x348_GTW_brakePressed(can_0x348_GTW_status_t *record, uint8_t in)
{
	record->GTW_brakePressed = in;
	return true;
}

bool decode_can_0x348_GTW_driverPresent(can_0x348_GTW_status_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->GTW_driverPresent);
	*out = rval;
	return true;
}

bool encode_can_0x348_GTW_driverPresent(can_0x348_GTW_status_t *record, uint8_t in)
{
	record->GTW_driverPresent = in;
	return true;
}

bool decode_can_0x348_GTW_notEnough12VForDrive(can_0x348_GTW_status_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->GTW_notEnough12VForDrive);
	*out = rval;
	return true;
}

bool encode_can_0x348_GTW_notEnough12VForDrive(can_0x348_GTW_status_t *record, uint8_t in)
{
	record->GTW_notEnough12VForDrive = in;
	return true;
}

bool decode_can_0x348_GTW_icPowerOff(can_0x348_GTW_status_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->GTW_icPowerOff);
	*out = rval;
	return true;
}

bool encode_can_0x348_GTW_icPowerOff(can_0x348_GTW_status_t *record, uint8_t in)
{
	record->GTW_icPowerOff = in;
	return true;
}

bool decode_can_0x348_GTW_driverIsLeaving(can_0x348_GTW_status_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->GTW_driverIsLeaving);
	*out = rval;
	return true;
}

bool encode_can_0x348_GTW_driverIsLeaving(can_0x348_GTW_status_t *record, uint8_t in)
{
	record->GTW_driverIsLeaving = in;
	return true;
}

bool decode_can_0x348_GTW_accGoingDown(can_0x348_GTW_status_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->GTW_accGoingDown);
	*out = rval;
	return true;
}

bool encode_can_0x348_GTW_accGoingDown(can_0x348_GTW_status_t *record, uint8_t in)
{
	record->GTW_accGoingDown = in;
	return true;
}

bool decode_can_0x348_GTW_driveGoingDown(can_0x348_GTW_status_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->GTW_driveGoingDown);
	*out = rval;
	return true;
}

bool encode_can_0x348_GTW_driveGoingDown(can_0x348_GTW_status_t *record, uint8_t in)
{
	record->GTW_driveGoingDown = in;
	return true;
}

bool decode_can_0x348_GTW_accRailReq(can_0x348_GTW_status_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->GTW_accRailReq);
	*out = rval;
	return true;
}

bool encode_can_0x348_GTW_accRailReq(can_0x348_GTW_status_t *record, uint8_t in)
{
	record->GTW_accRailReq = in;
	return true;
}

bool decode_can_0x348_GTW_hvacRailReq(can_0x348_GTW_status_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->GTW_hvacRailReq);
	*out = rval;
	return true;
}

bool encode_can_0x348_GTW_hvacRailReq(can_0x348_GTW_status_t *record, uint8_t in)
{
	record->GTW_hvacRailReq = in;
	return true;
}

bool decode_can_0x348_GTW_preconditionRequest(can_0x348_GTW_status_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->GTW_preconditionRequest);
	*out = rval;
	return true;
}

bool encode_can_0x348_GTW_preconditionRequest(can_0x348_GTW_status_t *record, uint8_t in)
{
	record->GTW_preconditionRequest = in;
	return true;
}

bool decode_can_0x348_GTW_hvacGoingDown(can_0x348_GTW_status_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->GTW_hvacGoingDown);
	*out = rval;
	return true;
}

bool encode_can_0x348_GTW_hvacGoingDown(can_0x348_GTW_status_t *record, uint8_t in)
{
	record->GTW_hvacGoingDown = in;
	return true;
}

int print_can_0x348_GTW_status(can_0x348_GTW_status_t *print, FILE *data)
{
	int r = 0;
	r = phelper(r, fprintf(data, "GTW_statusChecksum = (wire: %.0f)\n", (double)(print->GTW_statusChecksum)));
	r = phelper(r, fprintf(data, "GTW_statusCounter = (wire: %.0f)\n", (double)(print->GTW_statusCounter)));
	r = phelper(r, fprintf(data, "GTW_driveRailReq = (wire: %.0f)\n", (double)(print->GTW_driveRailReq)));
	r = phelper(r, fprintf(data, "GTW_brakePressed = (wire: %.0f)\n", (double)(print->GTW_brakePressed)));
	r = phelper(r, fprintf(data, "GTW_driverPresent = (wire: %.0f)\n", (double)(print->GTW_driverPresent)));
	r = phelper(r, fprintf(data, "GTW_notEnough12VForDrive = (wire: %.0f)\n", (double)(print->GTW_notEnough12VForDrive)));
	r = phelper(r, fprintf(data, "GTW_icPowerOff = (wire: %.0f)\n", (double)(print->GTW_icPowerOff)));
	r = phelper(r, fprintf(data, "GTW_driverIsLeaving = (wire: %.0f)\n", (double)(print->GTW_driverIsLeaving)));
	r = phelper(r, fprintf(data, "GTW_accGoingDown = (wire: %.0f)\n", (double)(print->GTW_accGoingDown)));
	r = phelper(r, fprintf(data, "GTW_driveGoingDown = (wire: %.0f)\n", (double)(print->GTW_driveGoingDown)));
	r = phelper(r, fprintf(data, "GTW_accRailReq = (wire: %.0f)\n", (double)(print->GTW_accRailReq)));
	r = phelper(r, fprintf(data, "GTW_hvacRailReq = (wire: %.0f)\n", (double)(print->GTW_hvacRailReq)));
	r = phelper(r, fprintf(data, "GTW_preconditionRequest = (wire: %.0f)\n", (double)(print->GTW_preconditionRequest)));
	r = phelper(r, fprintf(data, "GTW_hvacGoingDown = (wire: %.0f)\n", (double)(print->GTW_hvacGoingDown)));
	return r;
}

int pack_can_0x368_DI_state(can_0x368_DI_state_t *pack, uint64_t *data)
{
	register uint64_t x;
	register uint64_t i = 0;
	/* DI_analogSpeed: start-bit 16, length 12, endianess intel, scaling 0.1, offset 0 */
	x = ((uint16_t)(pack->DI_analogSpeed)) & 0xfff;
	x <<= 16; 
	i |= x;
	/* DI_cruiseSet: start-bit 32, length 9, endianess intel, scaling 0.5, offset 0 */
	x = ((uint16_t)(pack->DI_cruiseSet)) & 0x1ff;
	x <<= 32; 
	i |= x;
	/* DI_digitalSpeed: start-bit 48, length 8, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_digitalSpeed)) & 0xff;
	x <<= 48; 
	i |= x;
	/* DI_stateChecksum: start-bit 56, length 8, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_stateChecksum)) & 0xff;
	x <<= 56; 
	i |= x;
	/* DI_cruiseState: start-bit 12, length 4, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_cruiseState)) & 0xf;
	x <<= 12; 
	i |= x;
	/* DI_stateCounter: start-bit 44, length 4, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_stateCounter)) & 0xf;
	x <<= 44; 
	i |= x;
	/* DI_systemState: start-bit 0, length 3, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_systemState)) & 0x7;
	i |= x;
	/* DI_vehicleHoldState: start-bit 3, length 3, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_vehicleHoldState)) & 0x7;
	x <<= 3; 
	i |= x;
	/* DI_state: start-bit 9, length 3, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_state)) & 0x7;
	x <<= 9; 
	i |= x;
	/* DI_immobilizerState: start-bit 28, length 3, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_immobilizerState)) & 0x7;
	x <<= 28; 
	i |= x;
	/* DI_aebState: start-bit 41, length 3, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_aebState)) & 0x7;
	x <<= 41; 
	i |= x;
	/* DI_proximity: start-bit 6, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_proximity)) & 0x1;
	x <<= 6; 
	i |= x;
	/* DI_driveReady: start-bit 7, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_driveReady)) & 0x1;
	x <<= 7; 
	i |= x;
	/* DI_regenLight: start-bit 8, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_regenLight)) & 0x1;
	x <<= 8; 
	i |= x;
	/* DI_speedUnits: start-bit 31, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DI_speedUnits)) & 0x1;
	x <<= 31; 
	i |= x;
	*data = (i);
	return 0;
}

int unpack_can_0x368_DI_state(can_0x368_DI_state_t *unpack, uint64_t data, uint8_t dlc)
{
	register uint64_t x;
	register uint64_t i = (data);
	if (dlc < 8)
		return -1;
	/* DI_analogSpeed: start-bit 16, length 12, endianess intel, scaling 0.1, offset 0 */
	x = (i >> 16) & 0xfff;
	unpack->DI_analogSpeed = x;
	/* DI_cruiseSet: start-bit 32, length 9, endianess intel, scaling 0.5, offset 0 */
	x = (i >> 32) & 0x1ff;
	unpack->DI_cruiseSet = x;
	/* DI_digitalSpeed: start-bit 48, length 8, endianess intel, scaling 1, offset 0 */
	x = (i >> 48) & 0xff;
	unpack->DI_digitalSpeed = x;
	/* DI_stateChecksum: start-bit 56, length 8, endianess intel, scaling 1, offset 0 */
	x = (i >> 56) & 0xff;
	unpack->DI_stateChecksum = x;
	/* DI_cruiseState: start-bit 12, length 4, endianess intel, scaling 1, offset 0 */
	x = (i >> 12) & 0xf;
	unpack->DI_cruiseState = x;
	/* DI_stateCounter: start-bit 44, length 4, endianess intel, scaling 1, offset 0 */
	x = (i >> 44) & 0xf;
	unpack->DI_stateCounter = x;
	/* DI_systemState: start-bit 0, length 3, endianess intel, scaling 1, offset 0 */
	x = i & 0x7;
	unpack->DI_systemState = x;
	/* DI_vehicleHoldState: start-bit 3, length 3, endianess intel, scaling 1, offset 0 */
	x = (i >> 3) & 0x7;
	unpack->DI_vehicleHoldState = x;
	/* DI_state: start-bit 9, length 3, endianess intel, scaling 1, offset 0 */
	x = (i >> 9) & 0x7;
	unpack->DI_state = x;
	/* DI_immobilizerState: start-bit 28, length 3, endianess intel, scaling 1, offset 0 */
	x = (i >> 28) & 0x7;
	unpack->DI_immobilizerState = x;
	/* DI_aebState: start-bit 41, length 3, endianess intel, scaling 1, offset 0 */
	x = (i >> 41) & 0x7;
	unpack->DI_aebState = x;
	/* DI_proximity: start-bit 6, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 6) & 0x1;
	unpack->DI_proximity = x;
	/* DI_driveReady: start-bit 7, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 7) & 0x1;
	unpack->DI_driveReady = x;
	/* DI_regenLight: start-bit 8, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 8) & 0x1;
	unpack->DI_regenLight = x;
	/* DI_speedUnits: start-bit 31, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 31) & 0x1;
	unpack->DI_speedUnits = x;
	return 0;
}

bool decode_can_0x368_DI_analogSpeed(can_0x368_DI_state_t *record, double *out)
{
	double rval = (double)(record->DI_analogSpeed);
	rval *= 0.1;
	if (rval <= 150) {
		*out = rval;
		return true;
	} else {
		*out = (double)0;
		return false;
	}
}

bool encode_can_0x368_DI_analogSpeed(can_0x368_DI_state_t *record, double in)
{
	record->DI_analogSpeed = 0;
	if (in > 150)
		return false;
	in *= 10;
	record->DI_analogSpeed = in;
	return true;
}

bool decode_can_0x368_DI_cruiseSet(can_0x368_DI_state_t *record, double *out)
{
	double rval = (double)(record->DI_cruiseSet);
	rval *= 0.5;
	if (rval <= 255.5) {
		*out = rval;
		return true;
	} else {
		*out = (double)0;
		return false;
	}
}

bool encode_can_0x368_DI_cruiseSet(can_0x368_DI_state_t *record, double in)
{
	record->DI_cruiseSet = 0;
	if (in > 255.5)
		return false;
	in *= 2;
	record->DI_cruiseSet = in;
	return true;
}

bool decode_can_0x368_DI_digitalSpeed(can_0x368_DI_state_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_digitalSpeed);
	if (rval <= 250) {
		*out = rval;
		return true;
	} else {
		*out = (uint8_t)0;
		return false;
	}
}

bool encode_can_0x368_DI_digitalSpeed(can_0x368_DI_state_t *record, uint8_t in)
{
	record->DI_digitalSpeed = 0;
	if (in > 250)
		return false;
	record->DI_digitalSpeed = in;
	return true;
}

bool decode_can_0x368_DI_stateChecksum(can_0x368_DI_state_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_stateChecksum);
	*out = rval;
	return true;
}

bool encode_can_0x368_DI_stateChecksum(can_0x368_DI_state_t *record, uint8_t in)
{
	record->DI_stateChecksum = in;
	return true;
}

bool decode_can_0x368_DI_cruiseState(can_0x368_DI_state_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_cruiseState);
	*out = rval;
	return true;
}

bool encode_can_0x368_DI_cruiseState(can_0x368_DI_state_t *record, uint8_t in)
{
	record->DI_cruiseState = in;
	return true;
}

bool decode_can_0x368_DI_stateCounter(can_0x368_DI_state_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_stateCounter);
	*out = rval;
	return true;
}

bool encode_can_0x368_DI_stateCounter(can_0x368_DI_state_t *record, uint8_t in)
{
	record->DI_stateCounter = in;
	return true;
}

bool decode_can_0x368_DI_systemState(can_0x368_DI_state_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_systemState);
	*out = rval;
	return true;
}

bool encode_can_0x368_DI_systemState(can_0x368_DI_state_t *record, uint8_t in)
{
	record->DI_systemState = in;
	return true;
}

bool decode_can_0x368_DI_vehicleHoldState(can_0x368_DI_state_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_vehicleHoldState);
	*out = rval;
	return true;
}

bool encode_can_0x368_DI_vehicleHoldState(can_0x368_DI_state_t *record, uint8_t in)
{
	record->DI_vehicleHoldState = in;
	return true;
}

bool decode_can_0x368_DI_state(can_0x368_DI_state_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_state);
	*out = rval;
	return true;
}

bool encode_can_0x368_DI_state(can_0x368_DI_state_t *record, uint8_t in)
{
	record->DI_state = in;
	return true;
}

bool decode_can_0x368_DI_immobilizerState(can_0x368_DI_state_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_immobilizerState);
	*out = rval;
	return true;
}

bool encode_can_0x368_DI_immobilizerState(can_0x368_DI_state_t *record, uint8_t in)
{
	record->DI_immobilizerState = in;
	return true;
}

bool decode_can_0x368_DI_aebState(can_0x368_DI_state_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_aebState);
	*out = rval;
	return true;
}

bool encode_can_0x368_DI_aebState(can_0x368_DI_state_t *record, uint8_t in)
{
	record->DI_aebState = in;
	return true;
}

bool decode_can_0x368_DI_proximity(can_0x368_DI_state_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_proximity);
	*out = rval;
	return true;
}

bool encode_can_0x368_DI_proximity(can_0x368_DI_state_t *record, uint8_t in)
{
	record->DI_proximity = in;
	return true;
}

bool decode_can_0x368_DI_driveReady(can_0x368_DI_state_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_driveReady);
	*out = rval;
	return true;
}

bool encode_can_0x368_DI_driveReady(can_0x368_DI_state_t *record, uint8_t in)
{
	record->DI_driveReady = in;
	return true;
}

bool decode_can_0x368_DI_regenLight(can_0x368_DI_state_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_regenLight);
	*out = rval;
	return true;
}

bool encode_can_0x368_DI_regenLight(can_0x368_DI_state_t *record, uint8_t in)
{
	record->DI_regenLight = in;
	return true;
}

bool decode_can_0x368_DI_speedUnits(can_0x368_DI_state_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DI_speedUnits);
	*out = rval;
	return true;
}

bool encode_can_0x368_DI_speedUnits(can_0x368_DI_state_t *record, uint8_t in)
{
	record->DI_speedUnits = in;
	return true;
}

int print_can_0x368_DI_state(can_0x368_DI_state_t *print, FILE *data)
{
	int r = 0;
	r = phelper(r, fprintf(data, "DI_analogSpeed = (wire: %.0f)\n", (double)(print->DI_analogSpeed)));
	r = phelper(r, fprintf(data, "DI_cruiseSet = (wire: %.0f)\n", (double)(print->DI_cruiseSet)));
	r = phelper(r, fprintf(data, "DI_digitalSpeed = (wire: %.0f)\n", (double)(print->DI_digitalSpeed)));
	r = phelper(r, fprintf(data, "DI_stateChecksum = (wire: %.0f)\n", (double)(print->DI_stateChecksum)));
	r = phelper(r, fprintf(data, "DI_cruiseState = (wire: %.0f)\n", (double)(print->DI_cruiseState)));
	r = phelper(r, fprintf(data, "DI_stateCounter = (wire: %.0f)\n", (double)(print->DI_stateCounter)));
	r = phelper(r, fprintf(data, "DI_systemState = (wire: %.0f)\n", (double)(print->DI_systemState)));
	r = phelper(r, fprintf(data, "DI_vehicleHoldState = (wire: %.0f)\n", (double)(print->DI_vehicleHoldState)));
	r = phelper(r, fprintf(data, "DI_state = (wire: %.0f)\n", (double)(print->DI_state)));
	r = phelper(r, fprintf(data, "DI_immobilizerState = (wire: %.0f)\n", (double)(print->DI_immobilizerState)));
	r = phelper(r, fprintf(data, "DI_aebState = (wire: %.0f)\n", (double)(print->DI_aebState)));
	r = phelper(r, fprintf(data, "DI_proximity = (wire: %.0f)\n", (double)(print->DI_proximity)));
	r = phelper(r, fprintf(data, "DI_driveReady = (wire: %.0f)\n", (double)(print->DI_driveReady)));
	r = phelper(r, fprintf(data, "DI_regenLight = (wire: %.0f)\n", (double)(print->DI_regenLight)));
	r = phelper(r, fprintf(data, "DI_speedUnits = (wire: %.0f)\n", (double)(print->DI_speedUnits)));
	return r;
}

int pack_can_0x370_EPAS_sysStatus(can_0x370_EPAS_sysStatus_t *pack, uint64_t *data)
{
	register uint64_t x;
	register uint64_t m = 0;
	/* EPAS_internalSAS: start-bit 37, length 14, endianess motorola, scaling 0.1, offset -819.2 */
	x = ((uint16_t)(pack->EPAS_internalSAS)) & 0x3fff;
	x <<= 16; 
	m |= x;
	/* EPAS_torsionBarTorque: start-bit 19, length 12, endianess motorola, scaling 0.01, offset -20.5 */
	x = ((uint16_t)(pack->EPAS_torsionBarTorque)) & 0xfff;
	x <<= 32; 
	m |= x;
	/* EPAS_steeringRackForce: start-bit 1, length 10, endianess motorola, scaling 50, offset -25575 */
	x = ((uint16_t)(pack->EPAS_steeringRackForce)) & 0x3ff;
	x <<= 48; 
	m |= x;
	/* EPAS_sysStatusChecksum: start-bit 63, length 8, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->EPAS_sysStatusChecksum)) & 0xff;
	m |= x;
	/* EPAS_currentTuneMode: start-bit 7, length 4, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->EPAS_currentTuneMode)) & 0xf;
	x <<= 60; 
	m |= x;
	/* EPAS_eacErrorCode: start-bit 23, length 4, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->EPAS_eacErrorCode)) & 0xf;
	x <<= 44; 
	m |= x;
	/* EPAS_sysStatusCounter: start-bit 51, length 4, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->EPAS_sysStatusCounter)) & 0xf;
	x <<= 8; 
	m |= x;
	/* EPAS_eacStatus: start-bit 55, length 3, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->EPAS_eacStatus)) & 0x7;
	x <<= 13; 
	m |= x;
	/* EPAS_handsOnLevel: start-bit 39, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->EPAS_handsOnLevel)) & 0x3;
	x <<= 30; 
	m |= x;
	/* EPAS_steeringFault: start-bit 2, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->EPAS_steeringFault)) & 0x1;
	x <<= 58; 
	m |= x;
	/* EPAS_steeringReduced: start-bit 3, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->EPAS_steeringReduced)) & 0x1;
	x <<= 59; 
	m |= x;
	*data = reverse_byte_order(m);
	return 0;
}

int unpack_can_0x370_EPAS_sysStatus(can_0x370_EPAS_sysStatus_t *unpack, uint64_t data, uint8_t dlc)
{
	register uint64_t x;
	register uint64_t m = reverse_byte_order(data);
	if (dlc < 8)
		return -1;
	/* EPAS_internalSAS: start-bit 37, length 14, endianess motorola, scaling 0.1, offset -819.2 */
	x = (m >> 16) & 0x3fff;
	unpack->EPAS_internalSAS = x;
	/* EPAS_torsionBarTorque: start-bit 19, length 12, endianess motorola, scaling 0.01, offset -20.5 */
	x = (m >> 32) & 0xfff;
	unpack->EPAS_torsionBarTorque = x;
	/* EPAS_steeringRackForce: start-bit 1, length 10, endianess motorola, scaling 50, offset -25575 */
	x = (m >> 48) & 0x3ff;
	unpack->EPAS_steeringRackForce = x;
	/* EPAS_sysStatusChecksum: start-bit 63, length 8, endianess motorola, scaling 1, offset 0 */
	x = m & 0xff;
	unpack->EPAS_sysStatusChecksum = x;
	/* EPAS_currentTuneMode: start-bit 7, length 4, endianess motorola, scaling 1, offset 0 */
	x = (m >> 60) & 0xf;
	unpack->EPAS_currentTuneMode = x;
	/* EPAS_eacErrorCode: start-bit 23, length 4, endianess motorola, scaling 1, offset 0 */
	x = (m >> 44) & 0xf;
	unpack->EPAS_eacErrorCode = x;
	/* EPAS_sysStatusCounter: start-bit 51, length 4, endianess motorola, scaling 1, offset 0 */
	x = (m >> 8) & 0xf;
	unpack->EPAS_sysStatusCounter = x;
	/* EPAS_eacStatus: start-bit 55, length 3, endianess motorola, scaling 1, offset 0 */
	x = (m >> 13) & 0x7;
	unpack->EPAS_eacStatus = x;
	/* EPAS_handsOnLevel: start-bit 39, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 30) & 0x3;
	unpack->EPAS_handsOnLevel = x;
	/* EPAS_steeringFault: start-bit 2, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 58) & 0x1;
	unpack->EPAS_steeringFault = x;
	/* EPAS_steeringReduced: start-bit 3, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 59) & 0x1;
	unpack->EPAS_steeringReduced = x;
	return 0;
}

bool decode_can_0x370_EPAS_internalSAS(can_0x370_EPAS_sysStatus_t *record, double *out)
{
	double rval = (double)(record->EPAS_internalSAS);
	rval *= 0.1;
	rval += -819.2;
	*out = rval;
	return true;
}

bool encode_can_0x370_EPAS_internalSAS(can_0x370_EPAS_sysStatus_t *record, double in)
{
	in += 819.2;
	in *= 10;
	record->EPAS_internalSAS = in;
	return true;
}

bool decode_can_0x370_EPAS_torsionBarTorque(can_0x370_EPAS_sysStatus_t *record, double *out)
{
	double rval = (double)(record->EPAS_torsionBarTorque);
	rval *= 0.01;
	rval += -20.5;
	*out = rval;
	return true;
}

bool encode_can_0x370_EPAS_torsionBarTorque(can_0x370_EPAS_sysStatus_t *record, double in)
{
	in += 20.5;
	in *= 100;
	record->EPAS_torsionBarTorque = in;
	return true;
}

bool decode_can_0x370_EPAS_steeringRackForce(can_0x370_EPAS_sysStatus_t *record, double *out)
{
	double rval = (double)(record->EPAS_steeringRackForce);
	rval *= 50;
	rval += -25575;
	*out = rval;
	return true;
}

bool encode_can_0x370_EPAS_steeringRackForce(can_0x370_EPAS_sysStatus_t *record, double in)
{
	in += 25575;
	in *= 0.02;
	record->EPAS_steeringRackForce = in;
	return true;
}

bool decode_can_0x370_EPAS_sysStatusChecksum(can_0x370_EPAS_sysStatus_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->EPAS_sysStatusChecksum);
	*out = rval;
	return true;
}

bool encode_can_0x370_EPAS_sysStatusChecksum(can_0x370_EPAS_sysStatus_t *record, uint8_t in)
{
	record->EPAS_sysStatusChecksum = in;
	return true;
}

bool decode_can_0x370_EPAS_currentTuneMode(can_0x370_EPAS_sysStatus_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->EPAS_currentTuneMode);
	if (rval >= 8) {
		*out = rval;
		return true;
	} else {
		*out = (uint8_t)0;
		return false;
	}
}

bool encode_can_0x370_EPAS_currentTuneMode(can_0x370_EPAS_sysStatus_t *record, uint8_t in)
{
	record->EPAS_currentTuneMode = 0;
	if (in < 8)
		return false;
	record->EPAS_currentTuneMode = in;
	return true;
}

bool decode_can_0x370_EPAS_eacErrorCode(can_0x370_EPAS_sysStatus_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->EPAS_eacErrorCode);
	*out = rval;
	return true;
}

bool encode_can_0x370_EPAS_eacErrorCode(can_0x370_EPAS_sysStatus_t *record, uint8_t in)
{
	record->EPAS_eacErrorCode = in;
	return true;
}

bool decode_can_0x370_EPAS_sysStatusCounter(can_0x370_EPAS_sysStatus_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->EPAS_sysStatusCounter);
	*out = rval;
	return true;
}

bool encode_can_0x370_EPAS_sysStatusCounter(can_0x370_EPAS_sysStatus_t *record, uint8_t in)
{
	record->EPAS_sysStatusCounter = in;
	return true;
}

bool decode_can_0x370_EPAS_eacStatus(can_0x370_EPAS_sysStatus_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->EPAS_eacStatus);
	if (rval >= 5) {
		*out = rval;
		return true;
	} else {
		*out = (uint8_t)0;
		return false;
	}
}

bool encode_can_0x370_EPAS_eacStatus(can_0x370_EPAS_sysStatus_t *record, uint8_t in)
{
	record->EPAS_eacStatus = 0;
	if (in < 5)
		return false;
	record->EPAS_eacStatus = in;
	return true;
}

bool decode_can_0x370_EPAS_handsOnLevel(can_0x370_EPAS_sysStatus_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->EPAS_handsOnLevel);
	*out = rval;
	return true;
}

bool encode_can_0x370_EPAS_handsOnLevel(can_0x370_EPAS_sysStatus_t *record, uint8_t in)
{
	record->EPAS_handsOnLevel = in;
	return true;
}

bool decode_can_0x370_EPAS_steeringFault(can_0x370_EPAS_sysStatus_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->EPAS_steeringFault);
	*out = rval;
	return true;
}

bool encode_can_0x370_EPAS_steeringFault(can_0x370_EPAS_sysStatus_t *record, uint8_t in)
{
	record->EPAS_steeringFault = in;
	return true;
}

bool decode_can_0x370_EPAS_steeringReduced(can_0x370_EPAS_sysStatus_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->EPAS_steeringReduced);
	*out = rval;
	return true;
}

bool encode_can_0x370_EPAS_steeringReduced(can_0x370_EPAS_sysStatus_t *record, uint8_t in)
{
	record->EPAS_steeringReduced = in;
	return true;
}

int print_can_0x370_EPAS_sysStatus(can_0x370_EPAS_sysStatus_t *print, FILE *data)
{
	int r = 0;
	r = phelper(r, fprintf(data, "EPAS_internalSAS = (wire: %.0f)\n", (double)(print->EPAS_internalSAS)));
	r = phelper(r, fprintf(data, "EPAS_torsionBarTorque = (wire: %.0f)\n", (double)(print->EPAS_torsionBarTorque)));
	r = phelper(r, fprintf(data, "EPAS_steeringRackForce = (wire: %.0f)\n", (double)(print->EPAS_steeringRackForce)));
	r = phelper(r, fprintf(data, "EPAS_sysStatusChecksum = (wire: %.0f)\n", (double)(print->EPAS_sysStatusChecksum)));
	r = phelper(r, fprintf(data, "EPAS_currentTuneMode = (wire: %.0f)\n", (double)(print->EPAS_currentTuneMode)));
	r = phelper(r, fprintf(data, "EPAS_eacErrorCode = (wire: %.0f)\n", (double)(print->EPAS_eacErrorCode)));
	r = phelper(r, fprintf(data, "EPAS_sysStatusCounter = (wire: %.0f)\n", (double)(print->EPAS_sysStatusCounter)));
	r = phelper(r, fprintf(data, "EPAS_eacStatus = (wire: %.0f)\n", (double)(print->EPAS_eacStatus)));
	r = phelper(r, fprintf(data, "EPAS_handsOnLevel = (wire: %.0f)\n", (double)(print->EPAS_handsOnLevel)));
	r = phelper(r, fprintf(data, "EPAS_steeringFault = (wire: %.0f)\n", (double)(print->EPAS_steeringFault)));
	r = phelper(r, fprintf(data, "EPAS_steeringReduced = (wire: %.0f)\n", (double)(print->EPAS_steeringReduced)));
	return r;
}

int pack_can_0x388_MCU_clusterBacklightRequest(can_0x388_MCU_clusterBacklightRequest_t *pack, uint64_t *data)
{
	register uint64_t x;
	register uint64_t i = 0;
	/* MCU_clusterBrightnessLevel: start-bit 8, length 8, endianess intel, scaling 0.5, offset 0 */
	x = ((uint8_t)(pack->MCU_clusterBrightnessLevel)) & 0xff;
	x <<= 8; 
	i |= x;
	/* MCU_clusterReadyForPowerOff: start-bit 5, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->MCU_clusterReadyForPowerOff)) & 0x1;
	x <<= 5; 
	i |= x;
	/* MCU_clusterReadyForDrive: start-bit 6, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->MCU_clusterReadyForDrive)) & 0x1;
	x <<= 6; 
	i |= x;
	/* MCU_clusterBacklightOn: start-bit 7, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(pack->MCU_clusterBacklightOn)) & 0x1;
	x <<= 7; 
	i |= x;
	*data = (i);
	return 0;
}

int unpack_can_0x388_MCU_clusterBacklightRequest(can_0x388_MCU_clusterBacklightRequest_t *unpack, uint64_t data, uint8_t dlc)
{
	register uint64_t x;
	register uint64_t i = (data);
	if (dlc < 3)
		return -1;
	/* MCU_clusterBrightnessLevel: start-bit 8, length 8, endianess intel, scaling 0.5, offset 0 */
	x = (i >> 8) & 0xff;
	unpack->MCU_clusterBrightnessLevel = x;
	/* MCU_clusterReadyForPowerOff: start-bit 5, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 5) & 0x1;
	unpack->MCU_clusterReadyForPowerOff = x;
	/* MCU_clusterReadyForDrive: start-bit 6, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 6) & 0x1;
	unpack->MCU_clusterReadyForDrive = x;
	/* MCU_clusterBacklightOn: start-bit 7, length 1, endianess intel, scaling 1, offset 0 */
	x = (i >> 7) & 0x1;
	unpack->MCU_clusterBacklightOn = x;
	return 0;
}

bool decode_can_0x388_MCU_clusterBrightnessLevel(can_0x388_MCU_clusterBacklightRequest_t *record, double *out)
{
	double rval = (double)(record->MCU_clusterBrightnessLevel);
	rval *= 0.5;
	if (rval <= 127.5) {
		*out = rval;
		return true;
	} else {
		*out = (double)0;
		return false;
	}
}

bool encode_can_0x388_MCU_clusterBrightnessLevel(can_0x388_MCU_clusterBacklightRequest_t *record, double in)
{
	record->MCU_clusterBrightnessLevel = 0;
	if (in > 127.5)
		return false;
	in *= 2;
	record->MCU_clusterBrightnessLevel = in;
	return true;
}

bool decode_can_0x388_MCU_clusterReadyForPowerOff(can_0x388_MCU_clusterBacklightRequest_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->MCU_clusterReadyForPowerOff);
	*out = rval;
	return true;
}

bool encode_can_0x388_MCU_clusterReadyForPowerOff(can_0x388_MCU_clusterBacklightRequest_t *record, uint8_t in)
{
	record->MCU_clusterReadyForPowerOff = in;
	return true;
}

bool decode_can_0x388_MCU_clusterReadyForDrive(can_0x388_MCU_clusterBacklightRequest_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->MCU_clusterReadyForDrive);
	*out = rval;
	return true;
}

bool encode_can_0x388_MCU_clusterReadyForDrive(can_0x388_MCU_clusterBacklightRequest_t *record, uint8_t in)
{
	record->MCU_clusterReadyForDrive = in;
	return true;
}

bool decode_can_0x388_MCU_clusterBacklightOn(can_0x388_MCU_clusterBacklightRequest_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->MCU_clusterBacklightOn);
	*out = rval;
	return true;
}

bool encode_can_0x388_MCU_clusterBacklightOn(can_0x388_MCU_clusterBacklightRequest_t *record, uint8_t in)
{
	record->MCU_clusterBacklightOn = in;
	return true;
}

int print_can_0x388_MCU_clusterBacklightRequest(can_0x388_MCU_clusterBacklightRequest_t *print, FILE *data)
{
	int r = 0;
	r = phelper(r, fprintf(data, "MCU_clusterBrightnessLevel = (wire: %.0f)\n", (double)(print->MCU_clusterBrightnessLevel)));
	r = phelper(r, fprintf(data, "MCU_clusterReadyForPowerOff = (wire: %.0f)\n", (double)(print->MCU_clusterReadyForPowerOff)));
	r = phelper(r, fprintf(data, "MCU_clusterReadyForDrive = (wire: %.0f)\n", (double)(print->MCU_clusterReadyForDrive)));
	r = phelper(r, fprintf(data, "MCU_clusterBacklightOn = (wire: %.0f)\n", (double)(print->MCU_clusterBacklightOn)));
	return r;
}

int pack_can_0x3d8_MCU_locationStatus(can_0x3d8_MCU_locationStatus_t *pack, uint64_t *data)
{
	register uint64_t x;
	register uint64_t i = 0;
	/* MCU_latitude: start-bit 0, length 28, endianess intel, scaling 1e-06, offset 0 */
	x = ((uint32_t)(pack->MCU_latitude)) & 0xfffffff;
	i |= x;
	/* MCU_longitude: start-bit 28, length 28, endianess intel, scaling 1e-06, offset 0 */
	x = ((uint32_t)(pack->MCU_longitude)) & 0xfffffff;
	x <<= 28; 
	i |= x;
	/* MCU_gpsAccuracy: start-bit 56, length 7, endianess intel, scaling 0.2, offset 0 */
	x = ((uint8_t)(pack->MCU_gpsAccuracy)) & 0x7f;
	x <<= 56; 
	i |= x;
	*data = (i);
	return 0;
}

int unpack_can_0x3d8_MCU_locationStatus(can_0x3d8_MCU_locationStatus_t *unpack, uint64_t data, uint8_t dlc)
{
	register uint64_t x;
	register uint64_t i = (data);
	if (dlc < 8)
		return -1;
	/* MCU_latitude: start-bit 0, length 28, endianess intel, scaling 1e-06, offset 0 */
	x = i & 0xfffffff;
	x = x & 0x8000000 ? x | 0xf0000000 : x; 
	unpack->MCU_latitude = x;
	/* MCU_longitude: start-bit 28, length 28, endianess intel, scaling 1e-06, offset 0 */
	x = (i >> 28) & 0xfffffff;
	x = x & 0x8000000 ? x | 0xf0000000 : x; 
	unpack->MCU_longitude = x;
	/* MCU_gpsAccuracy: start-bit 56, length 7, endianess intel, scaling 0.2, offset 0 */
	x = (i >> 56) & 0x7f;
	unpack->MCU_gpsAccuracy = x;
	return 0;
}

bool decode_can_0x3d8_MCU_latitude(can_0x3d8_MCU_locationStatus_t *record, double *out)
{
	double rval = (double)(record->MCU_latitude);
	rval *= 1e-06;
	if ((rval >= -134.218) && (rval <= 134.218)) {
		*out = rval;
		return true;
	} else {
		*out = (double)0;
		return false;
	}
}

bool encode_can_0x3d8_MCU_latitude(can_0x3d8_MCU_locationStatus_t *record, double in)
{
	record->MCU_latitude = 0;
	if (in < -134.218)
		return false;
	if (in > 134.218)
		return false;
	in *= 1e+06;
	record->MCU_latitude = in;
	return true;
}

bool decode_can_0x3d8_MCU_longitude(can_0x3d8_MCU_locationStatus_t *record, double *out)
{
	double rval = (double)(record->MCU_longitude);
	rval *= 1e-06;
	if ((rval >= -268.435) && (rval <= 268.435)) {
		*out = rval;
		return true;
	} else {
		*out = (double)0;
		return false;
	}
}

bool encode_can_0x3d8_MCU_longitude(can_0x3d8_MCU_locationStatus_t *record, double in)
{
	record->MCU_longitude = 0;
	if (in < -268.435)
		return false;
	if (in > 268.435)
		return false;
	in *= 1e+06;
	record->MCU_longitude = in;
	return true;
}

bool decode_can_0x3d8_MCU_gpsAccuracy(can_0x3d8_MCU_locationStatus_t *record, double *out)
{
	double rval = (double)(record->MCU_gpsAccuracy);
	rval *= 0.2;
	if (rval <= 25.2) {
		*out = rval;
		return true;
	} else {
		*out = (double)0;
		return false;
	}
}

bool encode_can_0x3d8_MCU_gpsAccuracy(can_0x3d8_MCU_locationStatus_t *record, double in)
{
	record->MCU_gpsAccuracy = 0;
	if (in > 25.2)
		return false;
	in *= 5;
	record->MCU_gpsAccuracy = in;
	return true;
}

int print_can_0x3d8_MCU_locationStatus(can_0x3d8_MCU_locationStatus_t *print, FILE *data)
{
	int r = 0;
	r = phelper(r, fprintf(data, "MCU_latitude = (wire: %.0f)\n", (double)(print->MCU_latitude)));
	r = phelper(r, fprintf(data, "MCU_longitude = (wire: %.0f)\n", (double)(print->MCU_longitude)));
	r = phelper(r, fprintf(data, "MCU_gpsAccuracy = (wire: %.0f)\n", (double)(print->MCU_gpsAccuracy)));
	return r;
}

int pack_can_0x488_DAS_steeringControl(can_0x488_DAS_steeringControl_t *pack, uint64_t *data)
{
	register uint64_t x;
	register uint64_t m = 0;
	/* DAS_steeringAngleRequest: start-bit 6, length 15, endianess motorola, scaling 0.1, offset -1638.35 */
	x = ((uint16_t)(pack->DAS_steeringAngleRequest)) & 0x7fff;
	x <<= 48; 
	m |= x;
	/* DAS_steeringControlChecksum: start-bit 31, length 8, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DAS_steeringControlChecksum)) & 0xff;
	x <<= 32; 
	m |= x;
	/* DAS_steeringControlCounter: start-bit 19, length 4, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DAS_steeringControlCounter)) & 0xf;
	x <<= 40; 
	m |= x;
	/* DAS_steeringControlType: start-bit 23, length 2, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DAS_steeringControlType)) & 0x3;
	x <<= 46; 
	m |= x;
	/* DAS_steeringHapticRequest: start-bit 7, length 1, endianess motorola, scaling 1, offset 0 */
	x = ((uint8_t)(pack->DAS_steeringHapticRequest)) & 0x1;
	x <<= 63; 
	m |= x;
	*data = reverse_byte_order(m);
	return 0;
}

int unpack_can_0x488_DAS_steeringControl(can_0x488_DAS_steeringControl_t *unpack, uint64_t data, uint8_t dlc)
{
	register uint64_t x;
	register uint64_t m = reverse_byte_order(data);
	if (dlc < 4)
		return -1;
	/* DAS_steeringAngleRequest: start-bit 6, length 15, endianess motorola, scaling 0.1, offset -1638.35 */
	x = (m >> 48) & 0x7fff;
	unpack->DAS_steeringAngleRequest = x;
	/* DAS_steeringControlChecksum: start-bit 31, length 8, endianess motorola, scaling 1, offset 0 */
	x = (m >> 32) & 0xff;
	unpack->DAS_steeringControlChecksum = x;
	/* DAS_steeringControlCounter: start-bit 19, length 4, endianess motorola, scaling 1, offset 0 */
	x = (m >> 40) & 0xf;
	unpack->DAS_steeringControlCounter = x;
	/* DAS_steeringControlType: start-bit 23, length 2, endianess motorola, scaling 1, offset 0 */
	x = (m >> 46) & 0x3;
	unpack->DAS_steeringControlType = x;
	/* DAS_steeringHapticRequest: start-bit 7, length 1, endianess motorola, scaling 1, offset 0 */
	x = (m >> 63) & 0x1;
	unpack->DAS_steeringHapticRequest = x;
	return 0;
}

bool decode_can_0x488_DAS_steeringAngleRequest(can_0x488_DAS_steeringControl_t *record, double *out)
{
	double rval = (double)(record->DAS_steeringAngleRequest);
	rval *= 0.1;
	rval += -1638.35;
	if (rval <= 1638.35) {
		*out = rval;
		return true;
	} else {
		*out = (double)0;
		return false;
	}
}

bool encode_can_0x488_DAS_steeringAngleRequest(can_0x488_DAS_steeringControl_t *record, double in)
{
	record->DAS_steeringAngleRequest = 0;
	if (in > 1638.35)
		return false;
	in += 1638.35;
	in *= 10;
	record->DAS_steeringAngleRequest = in;
	return true;
}

bool decode_can_0x488_DAS_steeringControlChecksum(can_0x488_DAS_steeringControl_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DAS_steeringControlChecksum);
	*out = rval;
	return true;
}

bool encode_can_0x488_DAS_steeringControlChecksum(can_0x488_DAS_steeringControl_t *record, uint8_t in)
{
	record->DAS_steeringControlChecksum = in;
	return true;
}

bool decode_can_0x488_DAS_steeringControlCounter(can_0x488_DAS_steeringControl_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DAS_steeringControlCounter);
	*out = rval;
	return true;
}

bool encode_can_0x488_DAS_steeringControlCounter(can_0x488_DAS_steeringControl_t *record, uint8_t in)
{
	record->DAS_steeringControlCounter = in;
	return true;
}

bool decode_can_0x488_DAS_steeringControlType(can_0x488_DAS_steeringControl_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DAS_steeringControlType);
	*out = rval;
	return true;
}

bool encode_can_0x488_DAS_steeringControlType(can_0x488_DAS_steeringControl_t *record, uint8_t in)
{
	record->DAS_steeringControlType = in;
	return true;
}

bool decode_can_0x488_DAS_steeringHapticRequest(can_0x488_DAS_steeringControl_t *record, uint8_t *out)
{
	uint8_t rval = (uint8_t)(record->DAS_steeringHapticRequest);
	*out = rval;
	return true;
}

bool encode_can_0x488_DAS_steeringHapticRequest(can_0x488_DAS_steeringControl_t *record, uint8_t in)
{
	record->DAS_steeringHapticRequest = in;
	return true;
}

int print_can_0x488_DAS_steeringControl(can_0x488_DAS_steeringControl_t *print, FILE *data)
{
	int r = 0;
	r = phelper(r, fprintf(data, "DAS_steeringAngleRequest = (wire: %.0f)\n", (double)(print->DAS_steeringAngleRequest)));
	r = phelper(r, fprintf(data, "DAS_steeringControlChecksum = (wire: %.0f)\n", (double)(print->DAS_steeringControlChecksum)));
	r = phelper(r, fprintf(data, "DAS_steeringControlCounter = (wire: %.0f)\n", (double)(print->DAS_steeringControlCounter)));
	r = phelper(r, fprintf(data, "DAS_steeringControlType = (wire: %.0f)\n", (double)(print->DAS_steeringControlType)));
	r = phelper(r, fprintf(data, "DAS_steeringHapticRequest = (wire: %.0f)\n", (double)(print->DAS_steeringHapticRequest)));
	return r;
}

